{
    "language": "Solidity",
    "sources": {
        "contracts/CL/core/RamsesV3Pool.sol": {
            "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity ^0.8.0;\n\nimport {\n    IRamsesV3PoolActions,\n    IRamsesV3PoolDerivedState,\n    IRamsesV3PoolOwnerActions,\n    IRamsesV3Pool\n} from \"./interfaces/IRamsesV3Pool.sol\";\n\nimport {SafeCast} from \"./libraries/SafeCast.sol\";\nimport {Tick} from \"./libraries/Tick.sol\";\nimport {TickBitmap} from \"./libraries/TickBitmap.sol\";\nimport {Position} from \"./libraries/Position.sol\";\nimport {Oracle} from \"./libraries/Oracle.sol\";\n\nimport {FullMath} from \"./libraries/FullMath.sol\";\nimport {FixedPoint128} from \"./libraries/FixedPoint128.sol\";\nimport {TransferHelper} from \"./libraries/TransferHelper.sol\";\nimport {TickMath} from \"./libraries/TickMath.sol\";\nimport {SqrtPriceMath} from \"./libraries/SqrtPriceMath.sol\";\nimport {SwapMath} from \"./libraries/SwapMath.sol\";\n\nimport {IRamsesV3PoolDeployer} from \"./interfaces/IRamsesV3PoolDeployer.sol\";\nimport {IRamsesV3Factory} from \"./interfaces/IRamsesV3Factory.sol\";\nimport {IERC20Minimal} from \"./interfaces/IERC20Minimal.sol\";\nimport {IUniswapV3MintCallback} from \"./interfaces/callback/IUniswapV3MintCallback.sol\";\nimport {IUniswapV3SwapCallback} from \"./interfaces/callback/IUniswapV3SwapCallback.sol\";\nimport {IUniswapV3FlashCallback} from \"./interfaces/callback/IUniswapV3FlashCallback.sol\";\n\nimport {ProtocolActions} from \"./libraries/ProtocolActions.sol\";\nimport {\n    PoolStorage,\n    Slot0,\n    Observation,\n    PositionInfo,\n    TickInfo,\n    PeriodInfo,\n    ProtocolFees,\n    RewarderCheckpoint\n} from \"./libraries/PoolStorage.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/interfaces/IERC20.sol\";\n\ncontract RamsesV3Pool is IRamsesV3Pool {\n    using SafeCast for uint256;\n    using SafeCast for int256;\n    using Tick for mapping(int24 => TickInfo);\n    using TickBitmap for mapping(int16 => uint256);\n    using Position for mapping(bytes32 => PositionInfo);\n    using Position for PositionInfo;\n\n    address public immutable factory;\n    address public immutable token0;\n    address public immutable token1;\n\n    int24 public immutable tickSpacing;\n    uint128 public immutable maxLiquidityPerTick;\n\n    uint256 internal constant FEE_DENOM = 1_000_000;\n\n    /// @dev Mutually exclusive reentrancy protection into the pool to/from a method. This method also prevents entrance\n    /// @dev to a function before the pool is initialized. The reentrancy guard is required throughout the contract because\n    /// @dev we use balance checks to determine the payment status of interactions such as mint, swap and flash.\n    modifier lock() {\n        PoolStorage.PoolState storage $ = PoolStorage.getStorage();\n        if (!$.slot0.unlocked) revert LOK();\n        $.slot0.unlocked = false;\n        _;\n        $.slot0.unlocked = true;\n    }\n\n    /// @dev Advances period if it's a new week\n    modifier advancePeriod() {\n        _advancePeriod();\n        _;\n    }\n\n    constructor() {\n        PoolStorage.PoolState storage $ = PoolStorage.getStorage();\n\n        (factory, token0, token1, $.fee, tickSpacing) = IRamsesV3PoolDeployer(msg.sender).parameters();\n\n        maxLiquidityPerTick = Tick.tickSpacingToMaxLiquidityPerTick(tickSpacing);\n    }\n\n    /// @dev Common checks for valid tick inputs.\n    function checkTicks(int24 tickLower, int24 tickUpper) private pure {\n        /// @dev ensure lower tick is not greater than or equal to the upper tick\n        if (tickLower >= tickUpper) revert TLU();\n        /// @dev ensure tickLower is greater than the minimum tick\n        if (tickLower < TickMath.MIN_TICK) revert TLM();\n        /// @dev ensure tickUpper is less than the maximum tick\n        if (tickUpper > TickMath.MAX_TICK) revert TUM();\n    }\n\n    /// @dev Returns the block timestamp truncated to 32 bits, i.e. mod 2**32. This method is overridden in tests.\n    function _blockTimestamp() internal view virtual returns (uint32) {\n        /// @dev truncation is desired\n        return uint32(block.timestamp);\n    }\n\n    /// @dev Get the pool's balance of token0\n    /// @dev This function is gas optimized to avoid a redundant extcodesize check in addition to the returndatasize\n    function balance0() internal view returns (uint256) {\n        return IERC20(token0).balanceOf(address(this));\n    }\n\n    /// @dev Get the pool's balance of token1\n    /// @dev This function is gas optimized to avoid a redundant extcodesize check in addition to the returndatasize\n    function balance1() internal view returns (uint256) {\n        return IERC20(token1).balanceOf(address(this));\n    }\n\n    /// @inheritdoc IRamsesV3PoolDerivedState\n    function snapshotCumulativesInside(int24 tickLower, int24 tickUpper)\n        external\n        view\n        override\n        returns (int56 tickCumulativeInside, uint160 secondsPerLiquidityInsideX128, uint32 secondsInside)\n    {\n        checkTicks(tickLower, tickUpper);\n\n        return Oracle.snapshotCumulativesInside(tickLower, tickUpper, _blockTimestamp());\n    }\n\n    /// @inheritdoc IRamsesV3PoolDerivedState\n    function observe(uint32[] calldata secondsAgos)\n        external\n        view\n        override\n        returns (int56[] memory tickCumulatives, uint160[] memory secondsPerLiquidityCumulativeX128s)\n    {\n        PoolStorage.PoolState storage $ = PoolStorage.getStorage();\n\n        return Oracle.observe(\n            $.observations,\n            _blockTimestamp(),\n            secondsAgos,\n            $.slot0.tick,\n            $.slot0.observationIndex,\n            $.liquidity,\n            $.slot0.observationCardinality\n        );\n    }\n\n    /// @inheritdoc IRamsesV3PoolActions\n    function increaseObservationCardinalityNext(uint16 observationCardinalityNext) external override lock {\n        PoolStorage.PoolState storage $ = PoolStorage.getStorage();\n        /// @dev for the event\n        uint16 observationCardinalityNextOld = $.slot0.observationCardinalityNext;\n        uint16 observationCardinalityNextNew =\n            Oracle.grow($.observations, observationCardinalityNextOld, observationCardinalityNext);\n        $.slot0.observationCardinalityNext = observationCardinalityNextNew;\n        if (observationCardinalityNextOld != observationCardinalityNextNew) {\n            emit IncreaseObservationCardinalityNext(observationCardinalityNextOld, observationCardinalityNextNew);\n        }\n    }\n\n    /// @dev init\n    function initialize(uint160 sqrtPriceX96) external {\n        PoolStorage.PoolState storage $ = PoolStorage.getStorage();\n\n        if ($.slot0.sqrtPriceX96 != 0) revert AI();\n\n        int24 tick = TickMath.getTickAtSqrtRatio(sqrtPriceX96);\n\n        (uint16 cardinality, uint16 cardinalityNext) = Oracle.initialize($.observations, 0);\n\n        uint24 _feeProtocol = IRamsesV3Factory(factory).poolFeeProtocol(address(this));\n\n        _advancePeriod();\n\n        $.slot0 = Slot0({\n            sqrtPriceX96: sqrtPriceX96,\n            tick: tick,\n            observationIndex: 0,\n            observationCardinality: cardinality,\n            observationCardinalityNext: cardinalityNext,\n            feeProtocol: _feeProtocol,\n            unlocked: true\n        });\n\n        emit Initialize(sqrtPriceX96, tick);\n    }\n\n    struct ModifyPositionParams {\n        /// @dev the address that owns the position\n        address owner;\n        uint256 index;\n        /// @dev the lower and upper tick of the position\n        int24 tickLower;\n        int24 tickUpper;\n        /// @dev any change in liquidity\n        int128 liquidityDelta;\n    }\n\n    /// @dev Effect some changes to a position\n    /// @param params the position details and the change to the position's liquidity to effect\n    /// @return position a storage pointer referencing the position with the given owner and tick range\n    /// @return amount0 the amount of token0 owed to the pool, negative if the pool should pay the recipient\n    /// @return amount1 the amount of token1 owed to the pool, negative if the pool should pay the recipient\n    function _modifyPosition(ModifyPositionParams memory params)\n        private\n        returns (PositionInfo storage position, int256 amount0, int256 amount1)\n    {\n        PoolStorage.PoolState storage $ = PoolStorage.getStorage();\n\n        checkTicks(params.tickLower, params.tickUpper);\n        /// @dev SLOAD for gas optimization\n        Slot0 memory _slot0 = $.slot0;\n\n        position = Position._updatePosition(\n            Position.UpdatePositionParams({\n                owner: params.owner,\n                index: params.index,\n                tickLower: params.tickLower,\n                tickUpper: params.tickUpper,\n                liquidityDelta: params.liquidityDelta,\n                tick: _slot0.tick,\n                _blockTimestamp: _blockTimestamp(),\n                tickSpacing: tickSpacing,\n                maxLiquidityPerTick: maxLiquidityPerTick\n            })\n        );\n\n        if (params.liquidityDelta != 0) {\n            if (_slot0.tick < params.tickLower) {\n                /// @dev current tick is below the passed range; liquidity can only become in range by crossing from left to\n                /// @dev right, when we'll need _more_ token0 (it's becoming more valuable) so user must provide it\n                amount0 = SqrtPriceMath.getAmount0Delta(\n                    TickMath.getSqrtRatioAtTick(params.tickLower),\n                    TickMath.getSqrtRatioAtTick(params.tickUpper),\n                    params.liquidityDelta\n                );\n            } else if (_slot0.tick < params.tickUpper) {\n                /// @dev current tick is inside the passed range\n                /// @dev SLOAD for gas optimization\n                uint128 liquidityBefore = $.liquidity;\n\n                /// @dev write an oracle entry\n                ($.slot0.observationIndex, $.slot0.observationCardinality) = Oracle.write(\n                    $.observations,\n                    _slot0.observationIndex,\n                    _blockTimestamp(),\n                    _slot0.tick,\n                    liquidityBefore,\n                    _slot0.observationCardinality,\n                    _slot0.observationCardinalityNext\n                );\n\n                amount0 = SqrtPriceMath.getAmount0Delta(\n                    _slot0.sqrtPriceX96, TickMath.getSqrtRatioAtTick(params.tickUpper), params.liquidityDelta\n                );\n                amount1 = SqrtPriceMath.getAmount1Delta(\n                    TickMath.getSqrtRatioAtTick(params.tickLower), _slot0.sqrtPriceX96, params.liquidityDelta\n                );\n\n                $.liquidity = params.liquidityDelta < 0\n                    ? liquidityBefore - uint128(-params.liquidityDelta)\n                    : liquidityBefore + uint128(params.liquidityDelta);\n            } else {\n                /// @dev current tick is above the passed range; liquidity can only become in range by crossing from right to\n                /// @dev left, when we'll need _more_ token1 (it's becoming more valuable) so user must provide it\n                amount1 = SqrtPriceMath.getAmount1Delta(\n                    TickMath.getSqrtRatioAtTick(params.tickLower),\n                    TickMath.getSqrtRatioAtTick(params.tickUpper),\n                    params.liquidityDelta\n                );\n            }\n        }\n    }\n\n    /// @inheritdoc IRamsesV3PoolActions\n    function mint(\n        address recipient,\n        uint256 index,\n        int24 tickLower,\n        int24 tickUpper,\n        uint128 amount,\n        bytes calldata data\n    ) external override lock advancePeriod returns (uint256 amount0, uint256 amount1) {\n        require(amount > 0);\n        \n        int128 liquidityDelta = int256(uint256(amount)).toInt128();\n        \n        (, int256 amount0Int, int256 amount1Int) = _modifyPosition(\n            ModifyPositionParams({\n                owner: recipient,\n                index: index,\n                tickLower: tickLower,\n                tickUpper: tickUpper,\n                liquidityDelta: liquidityDelta\n            })\n        );\n\n        amount0 = uint256(amount0Int);\n        amount1 = uint256(amount1Int);\n\n        uint256 balance0Before;\n        uint256 balance1Before;\n        if (amount0 > 0) balance0Before = balance0();\n        if (amount1 > 0) balance1Before = balance1();\n        /// @dev CALLERS MUST INHERIT THE CALLBACKS\n        IUniswapV3MintCallback(msg.sender).uniswapV3MintCallback(amount0, amount1, data);\n        if (amount0 > 0 && balance0Before + amount0 > balance0()) revert M0();\n        if (amount1 > 0 && balance1Before + amount1 > balance1()) revert M1();\n\n        _updatePositionRewarderCheckpoint(recipient, index, tickLower, tickUpper, liquidityDelta);\n        emit Mint(msg.sender, recipient, tickLower, tickUpper, amount, amount0, amount1);\n    }\n\n    /// @inheritdoc IRamsesV3PoolActions\n    function collect(\n        address recipient,\n        uint256 index,\n        int24 tickLower,\n        int24 tickUpper,\n        uint128 amount0Requested,\n        uint128 amount1Requested\n    ) external override lock returns (uint128 amount0, uint128 amount1) {\n        PoolStorage.PoolState storage $ = PoolStorage.getStorage();\n\n        /// @dev we don't need to checkTicks here, because invalid positions will never have non-zero tokensOwed{0,1}\n        PositionInfo storage position = $.positions.get(msg.sender, index, tickLower, tickUpper);\n\n        amount0 = amount0Requested > position.tokensOwed0 ? position.tokensOwed0 : amount0Requested;\n        amount1 = amount1Requested > position.tokensOwed1 ? position.tokensOwed1 : amount1Requested;\n\n        unchecked {\n            if (amount0 > 0) {\n                position.tokensOwed0 -= amount0;\n                TransferHelper.safeTransfer(token0, recipient, amount0);\n            }\n            if (amount1 > 0) {\n                position.tokensOwed1 -= amount1;\n                TransferHelper.safeTransfer(token1, recipient, amount1);\n            }\n        }\n\n        emit Collect(msg.sender, recipient, tickLower, tickUpper, amount0, amount1);\n    }\n\n    /// @inheritdoc IRamsesV3PoolActions\n    function burn(uint256 index, int24 tickLower, int24 tickUpper, uint128 amount)\n        external\n        override\n        lock\n        advancePeriod\n        returns (uint256 amount0, uint256 amount1)\n    {\n        unchecked {\n            int128 liquidityDelta = -int256(uint256(amount)).toInt128();\n            \n            (PositionInfo storage position, int256 amount0Int, int256 amount1Int) = _modifyPosition(\n                ModifyPositionParams({\n                    owner: msg.sender,\n                    index: index,\n                    tickLower: tickLower,\n                    tickUpper: tickUpper,\n                    liquidityDelta: liquidityDelta\n                })\n            );\n\n            amount0 = uint256(-amount0Int);\n            amount1 = uint256(-amount1Int);\n\n            if (amount0 > 0 || amount1 > 0) {\n                (position.tokensOwed0, position.tokensOwed1) =\n                    (position.tokensOwed0 + uint128(amount0), position.tokensOwed1 + uint128(amount1));\n            }\n\n            _updatePositionRewarderCheckpoint(msg.sender, index, tickLower, tickUpper, liquidityDelta);\n            emit Burn(msg.sender, tickLower, tickUpper, amount, amount0, amount1);\n        }\n    }\n\n    struct SwapCache {\n        /// @dev the protocol fee for the input token\n        uint24 feeProtocol;\n        /// @dev liquidity at the beginning of the swap\n        uint128 liquidityStart;\n        /// @dev the timestamp of the current block\n        uint32 blockTimestamp;\n        /// @dev the current value of the tick accumulator, computed only if we cross an initialized tick\n        int56 tickCumulative;\n        /// @dev the current value of seconds per liquidity accumulator, computed only if we cross an initialized tick\n        uint160 secondsPerLiquidityCumulativeX128;\n        /// @dev whether we've computed and cached the above two accumulators\n        bool computedLatestObservation;\n        /// @dev timestamp of the previous period\n        uint32 previousPeriod;\n    }\n\n    /// @dev the top level state of the swap, the results of which are recorded in storage at the end\n    struct SwapState {\n        bool exactInput;\n        /// @dev the amount remaining to be swapped in/out of the input/output asset\n        int256 amountSpecifiedRemaining;\n        /// @dev the amount already swapped out/in of the output/input asset\n        int256 amountCalculated;\n        /// @dev current sqrt(price)\n        uint160 sqrtPriceX96;\n        /// @dev the tick associated with the current price\n        int24 tick;\n        /// @dev the global fee growth of the input token, minus protocol fees\n        uint256 feeGrowthGlobalX128;\n        /// @dev the global fee growth of the input token\n        uint256 grossFeeGrowthGlobalX128;\n        /// @dev amount of input token paid as protocol fee\n        uint128 protocolFee;\n        /// @dev the current liquidity in range\n        uint128 liquidity;\n        /// @dev seconds per liquidity at the end of the previous period\n        uint256 endSecondsPerLiquidityPeriodX128;\n        /// @dev starting tick of the current period\n        int24 periodStartTick;\n    }\n\n    struct StepComputations {\n        /// @dev the price at the beginning of the step\n        uint160 sqrtPriceStartX96;\n        /// @dev the next tick to swap to from the current tick in the swap direction\n        int24 tickNext;\n        /// @dev whether tickNext is initialized or not\n        bool initialized;\n        /// @dev sqrt(price) for the next tick (1/0)\n        uint160 sqrtPriceNextX96;\n        /// @dev how much is being swapped in in this step\n        uint256 amountIn;\n        /// @dev how much is being swapped out\n        uint256 amountOut;\n        /// @dev how much fee is being paid in\n        uint256 feeAmount;\n        uint256 _feeGrowthGlobal0X128;\n        uint256 _feeGrowthGlobal1X128;\n        int128 liquidityNet;\n    }\n\n    /// @inheritdoc IRamsesV3PoolActions\n    function swap(\n        address recipient,\n        bool zeroForOne,\n        int256 amountSpecified,\n        uint160 sqrtPriceLimitX96,\n        bytes calldata data\n    ) external override advancePeriod returns (int256 amount0, int256 amount1) {\n        PoolStorage.PoolState storage $ = PoolStorage.getStorage();\n\n        uint256 period = _blockTimestamp() / 1 weeks;\n        Slot0 memory slot0Start = $.slot0;\n\n        if (amountSpecified == 0) revert AS();\n\n        if (!slot0Start.unlocked) revert LOK();\n        require(\n            zeroForOne\n                ? sqrtPriceLimitX96 < slot0Start.sqrtPriceX96 && sqrtPriceLimitX96 > TickMath.MIN_SQRT_RATIO\n                : sqrtPriceLimitX96 > slot0Start.sqrtPriceX96 && sqrtPriceLimitX96 < TickMath.MAX_SQRT_RATIO,\n            SPL()\n        );\n\n        $.slot0.unlocked = false;\n\n        SwapCache memory cache = SwapCache({\n            liquidityStart: $.liquidity,\n            blockTimestamp: _blockTimestamp(),\n            feeProtocol: slot0Start.feeProtocol,\n            secondsPerLiquidityCumulativeX128: 0,\n            tickCumulative: 0,\n            computedLatestObservation: false,\n            previousPeriod: $.periods[period].previousPeriod\n        });\n\n        SwapState memory state = SwapState({\n            exactInput: amountSpecified > 0,\n            amountSpecifiedRemaining: amountSpecified,\n            amountCalculated: 0,\n            sqrtPriceX96: slot0Start.sqrtPriceX96,\n            tick: slot0Start.tick,\n            feeGrowthGlobalX128: zeroForOne ? $.feeGrowthGlobal0X128 : $.feeGrowthGlobal1X128,\n            grossFeeGrowthGlobalX128: zeroForOne ? $.grossFeeGrowthGlobal0X128 : $.grossFeeGrowthGlobal1X128,\n            protocolFee: 0,\n            liquidity: cache.liquidityStart,\n            endSecondsPerLiquidityPeriodX128: $.periods[cache.previousPeriod].endSecondsPerLiquidityPeriodX128,\n            periodStartTick: $.periods[period].startTick\n        });\n\n        /// @dev continue swapping as long as we haven't used the entire input/output and haven't reached the price limit\n        while (state.amountSpecifiedRemaining != 0 && state.sqrtPriceX96 != sqrtPriceLimitX96) {\n            StepComputations memory step;\n\n            step.sqrtPriceStartX96 = state.sqrtPriceX96;\n\n            (step.tickNext, step.initialized) =\n                $.tickBitmap.nextInitializedTickWithinOneWord(state.tick, tickSpacing, zeroForOne);\n\n            /// @dev ensure that we do not overshoot the min/max tick, as the tick bitmap is not aware of these bounds\n            if (step.tickNext < TickMath.MIN_TICK) {\n                step.tickNext = TickMath.MIN_TICK;\n            } else if (step.tickNext > TickMath.MAX_TICK) {\n                step.tickNext = TickMath.MAX_TICK;\n            }\n\n            /// @dev get the price for the next tick\n            step.sqrtPriceNextX96 = TickMath.getSqrtRatioAtTick(step.tickNext);\n\n            /// @dev compute values to swap to the target tick, price limit, or point where input/output amount is exhausted\n            (state.sqrtPriceX96, step.amountIn, step.amountOut, step.feeAmount) = SwapMath.computeSwapStep(\n                state.sqrtPriceX96,\n                (zeroForOne ? step.sqrtPriceNextX96 < sqrtPriceLimitX96 : step.sqrtPriceNextX96 > sqrtPriceLimitX96)\n                    ? sqrtPriceLimitX96\n                    : step.sqrtPriceNextX96,\n                state.liquidity,\n                state.amountSpecifiedRemaining,\n                $.fee\n            );\n\n            if (state.exactInput) {\n                /// @dev safe because we test that amountSpecified > amountIn + feeAmount in SwapMath\n                unchecked {\n                    state.amountSpecifiedRemaining -= (step.amountIn + step.feeAmount).toInt256();\n                }\n                state.amountCalculated -= step.amountOut.toInt256();\n            } else {\n                unchecked {\n                    state.amountSpecifiedRemaining += step.amountOut.toInt256();\n                }\n                state.amountCalculated += (step.amountIn + step.feeAmount).toInt256();\n            }\n\n            /// @dev update gross global fee tracker\n            if (state.liquidity > 0) {\n                unchecked {\n                    state.grossFeeGrowthGlobalX128 +=\n                        FullMath.mulDiv(step.feeAmount, FixedPoint128.Q128, state.liquidity);\n                }\n            }\n\n            /// @dev if the protocol fee is on, calculate how much is owed, decrement feeAmount, and increment protocolFee\n            if (cache.feeProtocol > 0) {\n                unchecked {\n                    uint256 delta = (step.feeAmount * cache.feeProtocol) / FEE_DENOM;\n                    step.feeAmount -= delta;\n                    state.protocolFee += uint128(delta);\n                }\n            }\n\n            /// @dev update global fee tracker\n            if (state.liquidity > 0) {\n                unchecked {\n                    state.feeGrowthGlobalX128 += FullMath.mulDiv(step.feeAmount, FixedPoint128.Q128, state.liquidity);\n                }\n            }\n\n            /// @dev shift tick if we reached the next price\n            if (state.sqrtPriceX96 == step.sqrtPriceNextX96) {\n                /// @dev if the tick is initialized, run the tick transition\n                if (step.initialized) {\n                    /// @dev check for the placeholder value, which we replace with the actual value the first time the swap\n                    /// @dev crosses an initialized tick\n                    if (!cache.computedLatestObservation) {\n                        (cache.tickCumulative, cache.secondsPerLiquidityCumulativeX128) = Oracle.observeSingle(\n                            $.observations,\n                            cache.blockTimestamp,\n                            0,\n                            slot0Start.tick,\n                            slot0Start.observationIndex,\n                            cache.liquidityStart,\n                            slot0Start.observationCardinality\n                        );\n                        cache.computedLatestObservation = true;\n                    }\n\n                    if (zeroForOne) {\n                        step._feeGrowthGlobal0X128 = state.feeGrowthGlobalX128;\n                        step._feeGrowthGlobal1X128 = $.feeGrowthGlobal1X128;\n                    } else {\n                        step._feeGrowthGlobal0X128 = $.feeGrowthGlobal0X128;\n                        step._feeGrowthGlobal1X128 = state.feeGrowthGlobalX128;\n                    }\n\n                    step.liquidityNet = $._ticks.cross(\n                        step.tickNext,\n                        step._feeGrowthGlobal0X128,\n                        step._feeGrowthGlobal1X128,\n                        cache.secondsPerLiquidityCumulativeX128,\n                        cache.tickCumulative,\n                        cache.blockTimestamp,\n                        state.endSecondsPerLiquidityPeriodX128,\n                        state.periodStartTick\n                    );\n                    /// @dev if we're moving leftward, we interpret liquidityNet as the opposite sign\n                    /// @dev safe because liquidityNet cannot be type(int128).min\n                    unchecked {\n                        if (zeroForOne) step.liquidityNet = -step.liquidityNet;\n                    }\n\n                    state.liquidity = step.liquidityNet < 0\n                        ? state.liquidity - uint128(-step.liquidityNet)\n                        : state.liquidity + uint128(step.liquidityNet);\n                }\n\n                unchecked {\n                    state.tick = zeroForOne ? step.tickNext - 1 : step.tickNext;\n                }\n            } else if (state.sqrtPriceX96 != step.sqrtPriceStartX96) {\n                /// @dev recompute unless we're on a lower tick boundary (i.e. already transitioned ticks), and haven't moved\n                state.tick = TickMath.getTickAtSqrtRatio(state.sqrtPriceX96);\n            }\n        }\n\n        /// @dev update tick and write an oracle entry if the tick change\n        if (state.tick != slot0Start.tick) {\n            (uint16 observationIndex, uint16 observationCardinality) = Oracle.write(\n                $.observations,\n                slot0Start.observationIndex,\n                cache.blockTimestamp,\n                slot0Start.tick,\n                cache.liquidityStart,\n                slot0Start.observationCardinality,\n                slot0Start.observationCardinalityNext\n            );\n\n            $.slot0.sqrtPriceX96 = state.sqrtPriceX96;\n            $.slot0.tick = state.tick;\n            $.slot0.observationIndex = observationIndex;\n            $.slot0.observationCardinality = observationCardinality;\n        } else {\n            /// @dev otherwise just update the price\n            $.slot0.sqrtPriceX96 = state.sqrtPriceX96;\n        }\n\n        /// @dev update liquidity if it changed\n        if (cache.liquidityStart != state.liquidity) $.liquidity = state.liquidity;\n\n        /// @dev update fee growth global and, if necessary, protocol fees\n        /// @dev overflow is acceptable, protocol has to withdraw before it hits type(uint128).max fees\n        if (zeroForOne) {\n            $.feeGrowthGlobal0X128 = state.feeGrowthGlobalX128;\n            $.grossFeeGrowthGlobal0X128 = state.grossFeeGrowthGlobalX128;\n            unchecked {\n                if (state.protocolFee > 0) $.protocolFees.token0 += state.protocolFee;\n            }\n        } else {\n            $.feeGrowthGlobal1X128 = state.feeGrowthGlobalX128;\n            $.grossFeeGrowthGlobal1X128 = state.grossFeeGrowthGlobalX128;\n            unchecked {\n                if (state.protocolFee > 0) $.protocolFees.token1 += state.protocolFee;\n            }\n        }\n\n        unchecked {\n            (amount0, amount1) = zeroForOne == state.exactInput\n                ? (amountSpecified - state.amountSpecifiedRemaining, state.amountCalculated)\n                : (state.amountCalculated, amountSpecified - state.amountSpecifiedRemaining);\n        }\n\n        /// @dev do the transfers and collect payment\n        if (zeroForOne) {\n            unchecked {\n                if (amount1 < 0) TransferHelper.safeTransfer(token1, recipient, uint256(-amount1));\n            }\n\n            uint256 balance0Before = balance0();\n            /// @dev CALLERS MUST INHERIT THE CALLBACKS\n            IUniswapV3SwapCallback(msg.sender).uniswapV3SwapCallback(amount0, amount1, data);\n            if (balance0Before + uint256(amount0) > balance0()) revert IIA();\n        } else {\n            unchecked {\n                if (amount0 < 0) TransferHelper.safeTransfer(token0, recipient, uint256(-amount0));\n            }\n\n            uint256 balance1Before = balance1();\n            /// @dev CALLERS MUST INHERIT THE CALLBACKS\n            IUniswapV3SwapCallback(msg.sender).uniswapV3SwapCallback(amount0, amount1, data);\n            if (balance1Before + uint256(amount1) > balance1()) revert IIA();\n        }\n\n        emit Swap(msg.sender, recipient, amount0, amount1, state.sqrtPriceX96, state.liquidity, state.tick);\n        $.slot0.unlocked = true;\n    }\n\n    /// @inheritdoc IRamsesV3PoolActions\n    function flash(address recipient, uint256 amount0, uint256 amount1, bytes calldata data) external override lock {\n        PoolStorage.PoolState storage $ = PoolStorage.getStorage();\n\n        uint128 _liquidity = $.liquidity;\n        if (_liquidity == 0) revert L();\n\n        uint256 balance0Before = balance0();\n        uint256 balance1Before = balance1();\n\n        if (amount0 > 0) TransferHelper.safeTransfer(token0, recipient, amount0);\n        if (amount1 > 0) TransferHelper.safeTransfer(token1, recipient, amount1);\n\n        uint256 balance0After;\n        uint256 balance1After;\n\n        /// @dev stack-too-deep\n        {\n            uint256 fee0 = FullMath.mulDivRoundingUp(amount0, $.fee, 1e6);\n            uint256 fee1 = FullMath.mulDivRoundingUp(amount1, $.fee, 1e6);\n            /// @dev CALLERS MUST INHERIT THE CALLBACKS\n            IUniswapV3FlashCallback(msg.sender).uniswapV3FlashCallback(fee0, fee1, data);\n\n            balance0After = balance0();\n            balance1After = balance1();\n\n            if (balance0Before + fee0 > balance0After) revert F0();\n            if (balance1Before + fee1 > balance1After) revert F1();\n        }\n\n        unchecked {\n            /// @dev sub is safe because we know balanceAfter is gt balanceBefore by at least fee\n            uint256 paid0 = balance0After - balance0Before;\n            uint256 paid1 = balance1After - balance1Before;\n\n            /// @dev stack-too-deep\n            {\n                uint24 feeProtocol = $.slot0.feeProtocol;\n                if (paid0 > 0) {\n                    uint256 pFees0 = feeProtocol == 0 ? 0 : (paid0 * feeProtocol) / FEE_DENOM;\n                    if (uint128(pFees0) > 0) $.protocolFees.token0 += uint128(pFees0);\n                    $.feeGrowthGlobal0X128 += FullMath.mulDiv(paid0 - pFees0, FixedPoint128.Q128, _liquidity);\n                    $.grossFeeGrowthGlobal0X128 += FullMath.mulDiv(paid0, FixedPoint128.Q128, _liquidity);\n                }\n                if (paid1 > 0) {\n                    uint256 pFees1 = feeProtocol == 0 ? 0 : (paid1 * feeProtocol) / FEE_DENOM;\n                    if (uint128(pFees1) > 0) $.protocolFees.token1 += uint128(pFees1);\n                    $.feeGrowthGlobal1X128 += FullMath.mulDiv(paid1 - pFees1, FixedPoint128.Q128, _liquidity);\n                    $.grossFeeGrowthGlobal0X128 += FullMath.mulDiv(paid1, FixedPoint128.Q128, _liquidity);\n                }\n            }\n\n            emit Flash(msg.sender, recipient, amount0, amount1, paid0, paid1);\n        }\n    }\n\n    /// @inheritdoc IRamsesV3PoolOwnerActions\n    function setFeeProtocol() external override lock {\n        ProtocolActions.setFeeProtocol(factory);\n    }\n\n    /// @inheritdoc IRamsesV3PoolOwnerActions\n    function collectProtocol(address recipient, uint128 amount0Requested, uint128 amount1Requested)\n        external\n        override\n        lock\n        returns (uint128 amount0, uint128 amount1)\n    {\n        require(msg.sender == IRamsesV3Factory(factory).feeCollector(), ProtocolActions.NOT_AUTHORIZED());\n\n        return ProtocolActions.collectProtocol(recipient, amount0Requested, amount1Requested, token0, token1);\n    }\n\n    /// @inheritdoc IRamsesV3PoolOwnerActions\n    function setFee(uint24 _fee) external override lock {\n        ProtocolActions.setFee(_fee, factory);\n    }\n\n    /// @inheritdoc IRamsesV3Pool\n    function _advancePeriod() public {\n        PoolStorage.PoolState storage $ = PoolStorage.getStorage();\n\n        /// @dev if in new week, record lastTick for previous period\n        /// @dev also record secondsPerLiquidityCumulativeX128 for the start of the new period\n        uint256 _lastPeriod = $.lastPeriod;\n        uint256 period = _blockTimestamp() / 1 weeks;\n\n        if (period != _lastPeriod) {\n            /// @dev use period - 1 if this is a new pool\n            if (_lastPeriod == 0) {\n                _lastPeriod = period - 1;\n            }\n\n            /// @dev loop from last unfilled period to current\n            /// @dev testing shows this uses 8m gas at 900 missed periods, around 17 years\n            for (uint256 i = _lastPeriod; i < period; ++i) {\n                Slot0 memory _slot0 = $.slot0;\n\n                /// @dev start new period in observations\n                uint160 secondsPerLiquidityCumulativeX128 =\n                    Oracle.newPeriod($.observations, _slot0.observationIndex, i + 1);\n\n                /// @dev record last tick and secondsPerLiquidityCumulativeX128 for old period\n                $.periods[i].lastTick = _slot0.tick;\n                $.periods[i].endSecondsPerLiquidityPeriodX128 = secondsPerLiquidityCumulativeX128;\n\n                /// @dev record start tick and secondsPerLiquidityCumulativeX128 for new period\n                PeriodInfo memory _newPeriod;\n\n                _newPeriod.previousPeriod = uint32(i);\n                _newPeriod.startTick = _slot0.tick;\n                $.periods[i + 1] = _newPeriod;\n            }\n\n            $.lastPeriod = period;\n        }\n    }\n\n    /// @notice get the fee charged by the pool for swaps and liquidity provision\n    function fee() external view override returns (uint24) {\n        return PoolStorage.getStorage().fee;\n    }\n\n    function readStorage(bytes32[] calldata slots) external view returns (bytes32[] memory returnData) {\n        uint256 slotsLength = slots.length;\n        returnData = new bytes32[](slotsLength);\n\n        for (uint256 i = 0; i < slotsLength; ++i) {\n            bytes32 slot = slots[i];\n            bytes32 _returnData;\n            assembly {\n                _returnData := sload(slot)\n            }\n            returnData[i] = _returnData;\n        }\n    }\n\n    /// @notice Get the Slot0 struct for the pool\n    function slot0()\n        external\n        view\n        override\n        returns (\n            uint160 sqrtPriceX96,\n            int24 tick,\n            uint16 observationIndex,\n            uint16 observationCardinality,\n            uint16 observationCardinalityNext,\n            uint24 feeProtocol,\n            bool unlocked\n        )\n    {\n        Slot0 memory _slot0 = PoolStorage.getStorage().slot0;\n\n        return (\n            _slot0.sqrtPriceX96,\n            _slot0.tick,\n            _slot0.observationIndex,\n            _slot0.observationCardinality,\n            _slot0.observationCardinalityNext,\n            _slot0.feeProtocol,\n            _slot0.unlocked\n        );\n    }\n\n    /// @notice Get the PeriodInfo struct for a given period in the pool\n    function periods(uint256 period)\n        external\n        view\n        returns (uint32 previousPeriod, int24 startTick, int24 lastTick, uint160 endSecondsPerLiquidityPeriodX128)\n    {\n        PeriodInfo memory periodData = PoolStorage.getStorage().periods[period];\n        return (\n            periodData.previousPeriod,\n            periodData.startTick,\n            periodData.lastTick,\n            periodData.endSecondsPerLiquidityPeriodX128\n        );\n    }\n\n    /// @notice Get the index of the last period in the pool\n    function lastPeriod() external view returns (uint256) {\n        return PoolStorage.getStorage().lastPeriod;\n    }\n\n    /// @notice Get the accumulated fee growth for the first token in the pool\n    function feeGrowthGlobal0X128() external view override returns (uint256) {\n        return PoolStorage.getStorage().feeGrowthGlobal0X128;\n    }\n\n    /// @notice Get the accumulated fee growth for the second token in the pool\n    function feeGrowthGlobal1X128() external view override returns (uint256) {\n        return PoolStorage.getStorage().feeGrowthGlobal1X128;\n    }\n\n    /// @notice Get the accumulated fee growth for the first token in the pool\n    function grossFeeGrowthGlobal0X128() external view override returns (uint256) {\n        return PoolStorage.getStorage().grossFeeGrowthGlobal0X128;\n    }\n\n    /// @notice Get the accumulated fee growth for the second token in the pool\n    function grossFeeGrowthGlobal1X128() external view override returns (uint256) {\n        return PoolStorage.getStorage().grossFeeGrowthGlobal1X128;\n    }\n\n    /// @notice Get the protocol fees accumulated by the pool\n    function protocolFees() external view override returns (uint128, uint128) {\n        ProtocolFees memory protocolFeesData = PoolStorage.getStorage().protocolFees;\n        return (protocolFeesData.token0, protocolFeesData.token1);\n    }\n\n    /// @notice Get the total liquidity of the pool\n    function liquidity() external view override returns (uint128) {\n        return PoolStorage.getStorage().liquidity;\n    }\n\n    /// @notice Get the ticks of the pool\n    function ticks(int24 tick)\n        external\n        view\n        override\n        returns (\n            uint128 liquidityGross,\n            int128 liquidityNet,\n            uint256 feeGrowthOutside0X128,\n            uint256 feeGrowthOutside1X128,\n            int56 tickCumulativeOutside,\n            uint160 secondsPerLiquidityOutsideX128,\n            uint32 secondsOutside,\n            bool initialized\n        )\n    {\n        TickInfo storage tickData = PoolStorage.getStorage()._ticks[tick];\n        liquidityGross = tickData.liquidityGross;\n        liquidityNet = tickData.liquidityNet;\n        feeGrowthOutside0X128 = tickData.feeGrowthOutside0X128;\n        feeGrowthOutside1X128 = tickData.feeGrowthOutside1X128;\n        tickCumulativeOutside = tickData.tickCumulativeOutside;\n        secondsPerLiquidityOutsideX128 = tickData.secondsPerLiquidityOutsideX128;\n        secondsOutside = tickData.secondsOutside;\n        initialized = tickData.initialized;\n    }\n\n    /// @notice Get the tick bitmap of the pool\n    function tickBitmap(int16 tick) external view override returns (uint256) {\n        return PoolStorage.getStorage().tickBitmap[tick];\n    }\n\n    /// @notice Get information about a specific position in the pool\n    function positions(bytes32 key)\n        external\n        view\n        override\n        returns (\n            uint128 liquidity,\n            uint256 feeGrowthInside0LastX128,\n            uint256 feeGrowthInside1LastX128,\n            uint128 tokensOwed0,\n            uint128 tokensOwed1\n        )\n    {\n        PositionInfo storage positionData = PoolStorage.getStorage().positions[key];\n        return (\n            positionData.liquidity,\n            positionData.feeGrowthInside0LastX128,\n            positionData.feeGrowthInside1LastX128,\n            positionData.tokensOwed0,\n            positionData.tokensOwed1\n        );\n    }\n\n    /// @notice Get the period seconds in range of a specific position\n    function positionPeriodSecondsInRange(\n        uint256 period,\n        address owner,\n        uint256 index,\n        int24 tickLower,\n        int24 tickUpper\n    ) external view returns (uint256 periodSecondsInsideX96) {\n        periodSecondsInsideX96 = Position.positionPeriodSecondsInRange(\n            Position.PositionPeriodSecondsInRangeParams({\n                period: period,\n                owner: owner,\n                index: index,\n                tickLower: tickLower,\n                tickUpper: tickUpper,\n                _blockTimestamp: _blockTimestamp()\n            })\n        );\n\n        return periodSecondsInsideX96;\n    }\n\n    /// @notice Get the observations recorded by the pool\n    function observations(uint256 index)\n        external\n        view\n        override\n        returns (\n            uint32 blockTimestamp,\n            int56 tickCumulative,\n            uint160 secondsPerLiquidityCumulativeX128,\n            bool initialized\n        )\n    {\n        Observation memory observationData = PoolStorage.getStorage().observations[index];\n        return (\n            observationData.blockTimestamp,\n            observationData.tickCumulative,\n            observationData.secondsPerLiquidityCumulativeX128,\n            observationData.initialized\n        );\n    }\n\n    /// @dev Update the position rewarder checkpoint\n    function _updatePositionRewarderCheckpoint(\n        address owner,\n        uint256 index,\n        int24 tickLower,\n        int24 tickUpper,\n        int128 liquidityDelta\n    ) private {\n        PoolStorage.PoolState storage $ = PoolStorage.getStorage();\n        bytes32 positionKey = Position.positionHash(owner, index, tickLower, tickUpper);\n        \n        $.positionLastRewarderCheckpoint[positionKey] = RewarderCheckpoint({\n            timestamp: _blockTimestamp(),\n            liquidityDelta: liquidityDelta\n        });\n    }\n\n    /// @notice Get the last rewarder checkpoint for a position\n    function positionLastRewarderCheckpoint(\n        address owner,\n        uint256 index,\n        int24 tickLower,\n        int24 tickUpper\n    ) external view returns (uint32 timestamp, int128 liquidityDelta) {\n        PoolStorage.PoolState storage $ = PoolStorage.getStorage();\n        bytes32 positionKey = Position.positionHash(owner, index, tickLower, tickUpper);\n        RewarderCheckpoint memory checkpoint = $.positionLastRewarderCheckpoint[positionKey];\n        \n        return (checkpoint.timestamp, checkpoint.liquidityDelta);\n    }\n}\n"
        },
        "contracts/CL/core/interfaces/IRamsesV3Pool.sol": {
            "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0;\n\nimport {IRamsesV3PoolImmutables} from \"./pool/IRamsesV3PoolImmutables.sol\";\nimport {IRamsesV3PoolState} from \"./pool/IRamsesV3PoolState.sol\";\nimport {IRamsesV3PoolDerivedState} from \"./pool/IRamsesV3PoolDerivedState.sol\";\nimport {IRamsesV3PoolActions} from \"./pool/IRamsesV3PoolActions.sol\";\nimport {IRamsesV3PoolOwnerActions} from \"./pool/IRamsesV3PoolOwnerActions.sol\";\nimport {IRamsesV3PoolErrors} from \"./pool/IRamsesV3PoolErrors.sol\";\nimport {IRamsesV3PoolEvents} from \"./pool/IRamsesV3PoolEvents.sol\";\n\n/// @title The interface for a Ramses V3 Pool\n/// @notice A Ramses pool facilitates swapping and automated market making between any two assets that strictly conform\n/// to the ERC20 specification\n/// @dev The pool interface is broken up into many smaller pieces\ninterface IRamsesV3Pool is\n    IRamsesV3PoolImmutables,\n    IRamsesV3PoolState,\n    IRamsesV3PoolDerivedState,\n    IRamsesV3PoolActions,\n    IRamsesV3PoolOwnerActions,\n    IRamsesV3PoolErrors,\n    IRamsesV3PoolEvents\n{\n    /// @notice if a new period, advance on interaction\n    function _advancePeriod() external;\n\n    /// @notice Get the index of the last period in the pool\n    /// @return The index of the last period\n    function lastPeriod() external view returns (uint256);\n\n    /// @notice allows reading arbitrary storage slots\n    function readStorage(bytes32[] calldata slots) external view returns (bytes32[] memory returnData);\n}\n"
        },
        "contracts/CL/core/libraries/SafeCast.sol": {
            "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0;\n\n/// @title Safe casting methods\n/// @notice Contains methods for safely casting between types\nlibrary SafeCast {\n    /// @notice Cast a uint256 to a uint160, revert on overflow\n    /// @param y The uint256 to be downcasted\n    /// @return z The downcasted integer, now type uint160\n    function toUint160(uint256 y) internal pure returns (uint160 z) {\n        require((z = uint160(y)) == y);\n    }\n\n    /// @notice Cast a int256 to a int128, revert on overflow or underflow\n    /// @param y The int256 to be downcasted\n    /// @return z The downcasted integer, now type int128\n    function toInt128(int256 y) internal pure returns (int128 z) {\n        require((z = int128(y)) == y);\n    }\n\n    /// @notice Cast a uint256 to a int256, revert on overflow\n    /// @param y The uint256 to be casted\n    /// @return z The casted integer, now type int256\n    function toInt256(uint256 y) internal pure returns (int256 z) {\n        require(y < 2 ** 255);\n        z = int256(y);\n    }\n}\n"
        },
        "contracts/CL/core/libraries/Tick.sol": {
            "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity ^0.8.0;\n\nimport {SafeCast} from './SafeCast.sol';\n\nimport {TickMath} from './TickMath.sol';\n\nimport {TickInfo} from './PoolStorage.sol';\n\n/// @title Tick\n/// @notice Contains functions for managing tick processes and relevant calculations\nlibrary Tick {\n    error LO();\n\n    using SafeCast for int256;\n\n    /// @notice Derives max liquidity per tick from given tick spacing\n    /// @dev Executed within the pool constructor\n    /// @param tickSpacing The amount of required tick separation, realized in multiples of `tickSpacing`\n    ///     e.g., a tickSpacing of 3 requires ticks to be initialized every 3rd tick i.e., ..., -6, -3, 0, 3, 6, ...\n    /// @return The max liquidity per tick\n    function tickSpacingToMaxLiquidityPerTick(int24 tickSpacing) internal pure returns (uint128) {\n        unchecked {\n            int24 minTick = (TickMath.MIN_TICK / tickSpacing) * tickSpacing;\n            int24 maxTick = (TickMath.MAX_TICK / tickSpacing) * tickSpacing;\n            uint24 numTicks = uint24((maxTick - minTick) / tickSpacing) + 1;\n            return type(uint128).max / numTicks;\n        }\n    }\n\n    /// @notice Retrieves fee growth data\n    /// @param self The mapping containing all tick information for initialized ticks\n    /// @param tickLower The lower tick boundary of the position\n    /// @param tickUpper The upper tick boundary of the position\n    /// @param tickCurrent The current tick\n    /// @param feeGrowthGlobal0X128 The all-time global fee growth, per unit of liquidity, in token0\n    /// @param feeGrowthGlobal1X128 The all-time global fee growth, per unit of liquidity, in token1\n    /// @return feeGrowthInside0X128 The all-time fee growth in token0, per unit of liquidity, inside the position's tick boundaries\n    /// @return feeGrowthInside1X128 The all-time fee growth in token1, per unit of liquidity, inside the position's tick boundaries\n    function getFeeGrowthInside(\n        mapping(int24 => TickInfo) storage self,\n        int24 tickLower,\n        int24 tickUpper,\n        int24 tickCurrent,\n        uint256 feeGrowthGlobal0X128,\n        uint256 feeGrowthGlobal1X128\n    ) internal view returns (uint256 feeGrowthInside0X128, uint256 feeGrowthInside1X128) {\n        unchecked {\n            TickInfo storage lower = self[tickLower];\n            TickInfo storage upper = self[tickUpper];\n\n            /// @dev calculate fee growth below\n            uint256 feeGrowthBelow0X128;\n            uint256 feeGrowthBelow1X128;\n            if (tickCurrent >= tickLower) {\n                feeGrowthBelow0X128 = lower.feeGrowthOutside0X128;\n                feeGrowthBelow1X128 = lower.feeGrowthOutside1X128;\n            } else {\n                feeGrowthBelow0X128 = feeGrowthGlobal0X128 - lower.feeGrowthOutside0X128;\n                feeGrowthBelow1X128 = feeGrowthGlobal1X128 - lower.feeGrowthOutside1X128;\n            }\n\n            /// @dev calculate fee growth above\n            uint256 feeGrowthAbove0X128;\n            uint256 feeGrowthAbove1X128;\n            if (tickCurrent < tickUpper) {\n                feeGrowthAbove0X128 = upper.feeGrowthOutside0X128;\n                feeGrowthAbove1X128 = upper.feeGrowthOutside1X128;\n            } else {\n                feeGrowthAbove0X128 = feeGrowthGlobal0X128 - upper.feeGrowthOutside0X128;\n                feeGrowthAbove1X128 = feeGrowthGlobal1X128 - upper.feeGrowthOutside1X128;\n            }\n\n            feeGrowthInside0X128 = feeGrowthGlobal0X128 - feeGrowthBelow0X128 - feeGrowthAbove0X128;\n            feeGrowthInside1X128 = feeGrowthGlobal1X128 - feeGrowthBelow1X128 - feeGrowthAbove1X128;\n        }\n    }\n\n    /// @notice Updates a tick and returns true if the tick was flipped from initialized to uninitialized, or vice versa\n    /// @param self The mapping containing all tick information for initialized ticks\n    /// @param tick The tick that will be updated\n    /// @param tickCurrent The current tick\n    /// @param liquidityDelta A new amount of liquidity to be added (subtracted) when tick is crossed from left to right (right to left)\n    /// @param feeGrowthGlobal0X128 The all-time global fee growth, per unit of liquidity, in token0\n    /// @param feeGrowthGlobal1X128 The all-time global fee growth, per unit of liquidity, in token1\n    /// @param secondsPerLiquidityCumulativeX128 The all-time seconds per max(1, liquidity) of the pool\n    /// @param tickCumulative The tick * time elapsed since the pool was first initialized\n    /// @param time The current block timestamp cast to a uint32\n    /// @param upper true for updating a position's upper tick, or false for updating a position's lower tick\n    /// @param maxLiquidity The maximum liquidity allocation for a single tick\n    /// @return flipped Whether the tick was flipped from initialized to uninitialized, or vice versa\n    function update(\n        mapping(int24 => TickInfo) storage self,\n        int24 tick,\n        int24 tickCurrent,\n        int128 liquidityDelta,\n        uint256 feeGrowthGlobal0X128,\n        uint256 feeGrowthGlobal1X128,\n        uint160 secondsPerLiquidityCumulativeX128,\n        int56 tickCumulative,\n        uint32 time,\n        bool upper,\n        uint128 maxLiquidity\n    ) internal returns (bool flipped) {\n        TickInfo storage info = self[tick];\n\n        uint128 liquidityGrossBefore = info.liquidityGross;\n        uint128 liquidityGrossAfter = liquidityDelta < 0\n            ? liquidityGrossBefore - uint128(-liquidityDelta)\n            : liquidityGrossBefore + uint128(liquidityDelta);\n\n        if (liquidityGrossAfter > maxLiquidity) revert LO();\n\n        flipped = (liquidityGrossAfter == 0) != (liquidityGrossBefore == 0);\n\n        if (liquidityGrossBefore == 0) {\n            /// @dev by convention, we assume that all growth before a tick was initialized happened _below_ the tick\n            if (tick <= tickCurrent) {\n                info.feeGrowthOutside0X128 = feeGrowthGlobal0X128;\n                info.feeGrowthOutside1X128 = feeGrowthGlobal1X128;\n                info.secondsPerLiquidityOutsideX128 = secondsPerLiquidityCumulativeX128;\n                info.tickCumulativeOutside = tickCumulative;\n                info.secondsOutside = time;\n            }\n            info.initialized = true;\n        }\n\n        info.liquidityGross = liquidityGrossAfter;\n\n        /// @dev when the lower (upper) tick is crossed left to right (right to left), liquidity must be added (removed)\n        info.liquidityNet = upper ? info.liquidityNet - liquidityDelta : info.liquidityNet + liquidityDelta;\n    }\n\n    /// @notice Clears tick data\n    /// @param self The mapping containing all initialized tick information for initialized ticks\n    /// @param tick The tick that will be cleared\n    /// @param period The period the tick was cleared on\n    function clear(mapping(int24 => TickInfo) storage self, int24 tick, uint256 period) internal {\n        delete self[tick].periodSecondsPerLiquidityOutsideX128[period];\n        delete self[tick];\n    }\n\n    /// @notice Transitions to next tick as needed by price movement\n    /// @param self The mapping containing all tick information for initialized ticks\n    /// @param tick The destination tick of the transition\n    /// @param feeGrowthGlobal0X128 The all-time global fee growth, per unit of liquidity, in token0\n    /// @param feeGrowthGlobal1X128 The all-time global fee growth, per unit of liquidity, in token1\n    /// @param secondsPerLiquidityCumulativeX128 The current seconds per liquidity\n    /// @param tickCumulative The tick * time elapsed since the pool was first initialized\n    /// @param time The current block.timestamp\n    /// @return liquidityNet The amount of liquidity added (subtracted) when tick is crossed from left to right (right to left)\n    function cross(\n        mapping(int24 => TickInfo) storage self,\n        int24 tick,\n        uint256 feeGrowthGlobal0X128,\n        uint256 feeGrowthGlobal1X128,\n        uint160 secondsPerLiquidityCumulativeX128,\n        int56 tickCumulative,\n        uint32 time,\n        uint256 endSecondsPerLiquidityPeriodX128,\n        int24 periodStartTick\n    ) internal returns (int128 liquidityNet) {\n        unchecked {\n            TickInfo storage info = self[tick];\n            uint256 period = time / 1 weeks;\n\n            info.feeGrowthOutside0X128 = feeGrowthGlobal0X128 - info.feeGrowthOutside0X128;\n            info.feeGrowthOutside1X128 = feeGrowthGlobal1X128 - info.feeGrowthOutside1X128;\n            info.secondsPerLiquidityOutsideX128 =\n                secondsPerLiquidityCumulativeX128 -\n                info.secondsPerLiquidityOutsideX128;\n            info.tickCumulativeOutside = tickCumulative - info.tickCumulativeOutside;\n            info.secondsOutside = time - info.secondsOutside;\n            liquidityNet = info.liquidityNet;\n\n            uint256 periodSecondsPerLiquidityOutsideX128;\n            uint256 periodSecondsPerLiquidityOutsideBeforeX128 = info.periodSecondsPerLiquidityOutsideX128[period];\n            if (tick <= periodStartTick && periodSecondsPerLiquidityOutsideBeforeX128 == 0) {\n                periodSecondsPerLiquidityOutsideX128 =\n                    secondsPerLiquidityCumulativeX128 -\n                    /* periodSecondsPerLiquidityOutsideBeforeX128 - */\n                    endSecondsPerLiquidityPeriodX128;\n            } else {\n                periodSecondsPerLiquidityOutsideX128 =\n                    secondsPerLiquidityCumulativeX128 -\n                    periodSecondsPerLiquidityOutsideBeforeX128;\n            }\n            info.periodSecondsPerLiquidityOutsideX128[period] = periodSecondsPerLiquidityOutsideX128;\n        }\n    }\n}\n"
        },
        "contracts/CL/core/libraries/TickBitmap.sol": {
            "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity ^0.8.0;\n\nimport {BitMath} from './BitMath.sol';\n\n/// @title Packed tick initialized state library\n/// @notice Stores a packed mapping of tick index to its initialized state\n/// @dev The mapping uses int16 for keys since ticks are represented as int24 and there are 256 (2^8) values per word.\nlibrary TickBitmap {\n    /// @notice Computes the position in the mapping where the initialized bit for a tick lives\n    /// @param tick The tick for which to compute the position\n    /// @return wordPos The key in the mapping containing the word in which the bit is stored\n    /// @return bitPos The bit position in the word where the flag is stored\n    function position(int24 tick) private pure returns (int16 wordPos, uint8 bitPos) {\n        unchecked {\n            wordPos = int16(tick >> 8);\n            bitPos = uint8(int8(tick % 256));\n        }\n    }\n\n    /// @notice Flips the initialized state for a given tick from false to true, or vice versa\n    /// @param self The mapping in which to flip the tick\n    /// @param tick The tick to flip\n    /// @param tickSpacing The spacing between usable ticks\n    function flipTick(mapping(int16 => uint256) storage self, int24 tick, int24 tickSpacing) internal {\n        unchecked {\n            /// @dev ensure that the tick is spaced\n            require(tick % tickSpacing == 0); \n            (int16 wordPos, uint8 bitPos) = position(tick / tickSpacing);\n            uint256 mask = 1 << bitPos;\n            self[wordPos] ^= mask;\n        }\n    }\n\n    /// @notice Returns the next initialized tick contained in the same word (or adjacent word) as the tick that is either\n    /// to the left (less than or equal to) or right (greater than) of the given tick\n    /// @param self The mapping in which to compute the next initialized tick\n    /// @param tick The starting tick\n    /// @param tickSpacing The spacing between usable ticks\n    /// @param lte Whether to search for the next initialized tick to the left (less than or equal to the starting tick)\n    /// @return next The next initialized or uninitialized tick up to 256 ticks away from the current tick\n    /// @return initialized Whether the next tick is initialized, as the function only searches within up to 256 ticks\n    function nextInitializedTickWithinOneWord(\n        mapping(int16 => uint256) storage self,\n        int24 tick,\n        int24 tickSpacing,\n        bool lte\n    ) internal view returns (int24 next, bool initialized) {\n        unchecked {\n            int24 compressed = tick / tickSpacing;\n            if (tick < 0 && tick % tickSpacing != 0) compressed--; /// @dev round towards negative infinity\n\n            if (lte) {\n                (int16 wordPos, uint8 bitPos) = position(compressed);\n                /// @dev all the 1s at or to the right of the current bitPos\n                uint256 mask = (1 << bitPos) - 1 + (1 << bitPos);\n                uint256 masked = self[wordPos] & mask;\n\n                /// @dev if there are no initialized ticks to the right of or at the current tick, return rightmost in the word\n                initialized = masked != 0;\n                /// @dev overflow/underflow is possible, but prevented externally by limiting both tickSpacing and tick\n                next = initialized\n                    ? (compressed - int24(uint24(bitPos - BitMath.mostSignificantBit(masked)))) * tickSpacing\n                    : (compressed - int24(uint24(bitPos))) * tickSpacing;\n            } else {\n                /// @dev start from the word of the next tick, since the current tick state doesn't matter\n                (int16 wordPos, uint8 bitPos) = position(compressed + 1);\n                /// @dev all the 1s at or to the left of the bitPos\n                uint256 mask = ~((1 << bitPos) - 1);\n                uint256 masked = self[wordPos] & mask;\n\n                /// @dev if there are no initialized ticks to the left of the current tick, return leftmost in the word\n                initialized = masked != 0;\n                /// @dev overflow/underflow is possible, but prevented externally by limiting both tickSpacing and tick\n                next = initialized\n                    ? (compressed + 1 + int24(uint24(BitMath.leastSignificantBit(masked) - bitPos))) * tickSpacing\n                    : (compressed + 1 + int24(uint24(type(uint8).max - bitPos))) * tickSpacing;\n            }\n        }\n    }\n}\n"
        },
        "contracts/CL/core/libraries/Position.sol": {
            "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity ^0.8.0;\n\nimport {FullMath} from \"./FullMath.sol\";\nimport {FixedPoint128} from \"./FixedPoint128.sol\";\nimport {FixedPoint32} from \"./FixedPoint32.sol\";\nimport {FixedPoint96} from \"./FixedPoint96.sol\";\nimport {Oracle} from \"./Oracle.sol\";\nimport {SafeCast} from \"./SafeCast.sol\";\nimport {Tick} from \"./Tick.sol\";\nimport {TickBitmap} from \"./TickBitmap.sol\";\n\nimport {PoolStorage, PositionInfo, PositionCheckpoint, RewardInfo} from \"./PoolStorage.sol\";\n\n/// @title Position\n/// @notice Positions represent an owner address' liquidity between a lower and upper tick boundary\n/// @dev Positions store additional state for tracking fees owed to the position\nlibrary Position {\n    error NP();\n    error FTR();\n\n    /// @notice Returns the hash used to store positions in a mapping\n    /// @param owner The address of the position owner\n    /// @param index The index of the position\n    /// @param tickLower The lower tick boundary of the position\n    /// @param tickUpper The upper tick boundary of the position\n    /// @return _hash The hash used to store positions in a mapping\n    function positionHash(address owner, uint256 index, int24 tickLower, int24 tickUpper)\n        internal\n        pure\n        returns (bytes32)\n    {\n        return keccak256(abi.encodePacked(owner, index, tickLower, tickUpper));\n    }\n\n    /// @notice Returns the Info struct of a position, given an owner and position boundaries\n    /// @param self The mapping containing all user positions\n    /// @param owner The address of the position owner\n    /// @param tickLower The lower tick boundary of the position\n    /// @param tickUpper The upper tick boundary of the position\n    /// @return position The position info struct of the given owners' position\n    function get(\n        mapping(bytes32 => PositionInfo) storage self,\n        address owner,\n        uint256 index,\n        int24 tickLower,\n        int24 tickUpper\n    ) internal view returns (PositionInfo storage position) {\n        position = self[positionHash(owner, index, tickLower, tickUpper)];\n    }\n\n    /// @notice Credits accumulated fees to a user's position\n    /// @param self The individual position to update\n    /// @param liquidityDelta The change in pool liquidity as a result of the position update\n    /// @param feeGrowthInside0X128 The all-time fee growth in token0, per unit of liquidity, inside the position's tick boundaries\n    /// @param feeGrowthInside1X128 The all-time fee growth in token1, per unit of liquidity, inside the position's tick boundaries\n    function update(\n        PositionInfo storage self,\n        int128 liquidityDelta,\n        uint256 feeGrowthInside0X128,\n        uint256 feeGrowthInside1X128,\n        bytes32 _positionHash,\n        uint256 period,\n        uint160 secondsPerLiquidityPeriodX128\n    ) internal {\n        PoolStorage.PoolState storage $ = PoolStorage.getStorage();\n\n        uint128 liquidity = self.liquidity;\n        uint128 liquidityNext;\n\n        if (liquidityDelta == 0) {\n            /// @dev disallow pokes for 0 liquidity positions\n            if (liquidity <= 0) revert NP();\n            liquidityNext = liquidity;\n        } else {\n            liquidityNext =\n                liquidityDelta < 0 ? liquidity - uint128(-liquidityDelta) : liquidity + uint128(liquidityDelta);\n        }\n\n        /// @dev calculate accumulated fees. overflow in the subtraction of fee growth is expected\n        /// @dev limit scope to avoid stack-too-deep\n        {\n            uint128 tokensOwed0;\n            uint128 tokensOwed1;\n            unchecked {\n                tokensOwed0 = uint128(\n                    FullMath.mulDiv(feeGrowthInside0X128 - self.feeGrowthInside0LastX128, liquidity, FixedPoint128.Q128)\n                );\n                tokensOwed1 = uint128(\n                    FullMath.mulDiv(feeGrowthInside1X128 - self.feeGrowthInside1LastX128, liquidity, FixedPoint128.Q128)\n                );\n\n                /// @dev update the position\n                if (liquidityDelta != 0) self.liquidity = liquidityNext;\n                self.feeGrowthInside0LastX128 = feeGrowthInside0X128;\n                self.feeGrowthInside1LastX128 = feeGrowthInside1X128;\n                if (tokensOwed0 > 0 || tokensOwed1 > 0) {\n                    /// @dev overflow is acceptable, user must withdraw before they hit type(uint128).max fees\n                    self.tokensOwed0 += tokensOwed0;\n                    self.tokensOwed1 += tokensOwed1;\n                }\n            }\n        }\n\n        /// @dev write checkpoint, push a checkpoint if the last period is different, overwrite if not\n        uint256 checkpointLength = $.positionCheckpoints[_positionHash].length;\n        if (checkpointLength == 0 || $.positionCheckpoints[_positionHash][checkpointLength - 1].period != period) {\n            $.positionCheckpoints[_positionHash].push(PositionCheckpoint({period: period, liquidity: liquidityNext}));\n        } else {\n            $.positionCheckpoints[_positionHash][checkpointLength - 1].liquidity = liquidityNext;\n        }\n\n        int160 secondsPerLiquidityPeriodIntX128 = int160(secondsPerLiquidityPeriodX128);\n\n        int160 secondsPerLiquidityPeriodStartX128 = self.periodRewardInfo[period].secondsPerLiquidityPeriodStartX128;\n\n        /// @dev take the difference to make the delta positive or zero\n        secondsPerLiquidityPeriodIntX128 -= secondsPerLiquidityPeriodStartX128;\n\n        /// @dev these int should never be negative\n        if (secondsPerLiquidityPeriodIntX128 < 0) {\n            secondsPerLiquidityPeriodIntX128 = 0;\n        }\n\n        /// @dev secondsDebtDeltaX96 is declared differently based on the liquidityDelta\n        int256 secondsDebtDeltaX96 = liquidityDelta > 0\n            /// @dev case: delta > 0\n            ? SafeCast.toInt256(\n                /// @dev round upwards\n                FullMath.mulDivRoundingUp(\n                    uint256(uint128(liquidityDelta)), uint256(uint160(secondsPerLiquidityPeriodIntX128)), FixedPoint32.Q32\n                )\n            )\n            /// @dev case: delta <= 0\n            : SafeCast.toInt256(\n                /// @dev round downwards\n                FullMath.mulDiv(\n                    /// @dev flip liquidityDelta sign\n                    uint256(uint128(-liquidityDelta)),\n                    uint256(uint160(secondsPerLiquidityPeriodIntX128)),\n                    FixedPoint32.Q32\n                )\n            );\n\n        self.periodRewardInfo[period].secondsDebtX96 = liquidityDelta > 0\n            ? self.periodRewardInfo[period].secondsDebtX96 + secondsDebtDeltaX96\n            /// @dev can't overflow since each period is way less than uint31\n            : self.periodRewardInfo[period].secondsDebtX96 - secondsDebtDeltaX96;\n    }\n\n    /// @notice gets the checkpoint directly before the period\n    /// @dev returns the 0th index if there's no checkpoints\n    /// @param checkpoints the position's checkpoints in storage\n    /// @param period the period of interest\n    function getCheckpoint(PositionCheckpoint[] storage checkpoints, uint256 period)\n        internal\n        view\n        returns (uint256 checkpointIndex, uint256 checkpointPeriod)\n    {\n        {\n            uint256 checkpointLength = checkpoints.length;\n\n            /// @dev return 0 if length is 0\n            if (checkpointLength == 0) {\n                return (0, 0);\n            }\n\n            checkpointPeriod = checkpoints[0].period;\n\n            /// @dev return 0 if first checkpoint happened after period\n            if (checkpointPeriod > period) {\n                return (0, 0);\n            }\n\n            checkpointIndex = checkpointLength - 1;\n        }\n\n        checkpointPeriod = checkpoints[checkpointIndex].period;\n\n        /// @dev Find relevant checkpoint if latest checkpoint isn't before period of interest\n        if (checkpointPeriod > period) {\n            uint256 lower = 0;\n            uint256 upper = checkpointIndex;\n\n            while (upper > lower) {\n                /// @dev ceil, avoiding overflow\n                uint256 center = upper - (upper - lower) / 2;\n                checkpointPeriod = checkpoints[center].period;\n                if (checkpointPeriod == period) {\n                    checkpointIndex = center;\n                    return (checkpointIndex, checkpointPeriod);\n                } else if (checkpointPeriod < period) {\n                    lower = center;\n                } else {\n                    upper = center - 1;\n                }\n            }\n            checkpointIndex = lower;\n            checkpointPeriod = checkpoints[checkpointIndex].period;\n        }\n\n        return (checkpointIndex, checkpointPeriod);\n    }\n\n    struct PositionPeriodSecondsInRangeParams {\n        uint256 period;\n        address owner;\n        uint256 index;\n        int24 tickLower;\n        int24 tickUpper;\n        uint32 _blockTimestamp;\n    }\n\n    /// @notice Get the period seconds in range of a specific position\n    /// @return periodSecondsInsideX96 seconds the position was not in range for the period\n    function positionPeriodSecondsInRange(PositionPeriodSecondsInRangeParams memory params)\n        public\n        view\n        returns (uint256 periodSecondsInsideX96)\n    {\n        PoolStorage.PoolState storage $ = PoolStorage.getStorage();\n\n        uint256 currentPeriod = $.lastPeriod;\n        if (params.period > currentPeriod) revert FTR();\n\n        bytes32 _positionHash = positionHash(params.owner, params.index, params.tickLower, params.tickUpper);\n\n        uint256 liquidity;\n        int160 secondsPerLiquidityPeriodStartX128;\n\n        PositionCheckpoint[] storage checkpoints = $.positionCheckpoints[_positionHash];\n\n        /// @dev get checkpoint at period, or last checkpoint before the period\n        (uint256 checkpointIndex, uint256 checkpointPeriod) = getCheckpoint(checkpoints, params.period);\n\n        /// @dev Return 0s if checkpointPeriod is 0\n        if (checkpointPeriod == 0) {\n            return 0;\n        }\n\n        liquidity = checkpoints[checkpointIndex].liquidity;\n\n        secondsPerLiquidityPeriodStartX128 =\n            $.positions[_positionHash].periodRewardInfo[params.period].secondsPerLiquidityPeriodStartX128;\n\n        uint160 secondsPerLiquidityInsideX128 = Oracle.periodCumulativesInside(\n            uint32(params.period), params.tickLower, params.tickUpper, params._blockTimestamp\n        );\n\n        /// @dev underflow will be protected by sanity check\n        secondsPerLiquidityInsideX128 =\n            uint160(int160(secondsPerLiquidityInsideX128) - secondsPerLiquidityPeriodStartX128);\n\n        RewardInfo storage rewardInfo = $.positions[_positionHash].periodRewardInfo[params.period];\n        int256 secondsDebtX96 = rewardInfo.secondsDebtX96;\n\n        /// @dev addDelta checks for under and overflows\n        periodSecondsInsideX96 = FullMath.mulDiv(liquidity, secondsPerLiquidityInsideX128, FixedPoint32.Q32);\n\n        /// @dev Need to check if secondsDebtX96>periodSecondsInsideX96, since rounding can cause underflows\n        if (secondsDebtX96 < 0 || periodSecondsInsideX96 > uint256(secondsDebtX96)) {\n            periodSecondsInsideX96 = secondsDebtX96 < 0\n                ? periodSecondsInsideX96 + uint256(-secondsDebtX96)\n                : periodSecondsInsideX96 - uint256(secondsDebtX96);\n        } else {\n            periodSecondsInsideX96 = 0;\n        }\n\n        /// @dev sanity\n        if (periodSecondsInsideX96 > 1 weeks * FixedPoint96.Q96) {\n            periodSecondsInsideX96 = 0;\n        }\n    }\n\n    struct UpdatePositionParams {\n        /// @dev the owner of the position\n        address owner;\n        /// @dev the index of the position\n        uint256 index;\n        /// @dev the lower tick of the position's tick range\n        int24 tickLower;\n        /// @dev the upper tick of the position's tick range\n        int24 tickUpper;\n        /// @dev the amount liquidity changes by\n        int128 liquidityDelta;\n        /// @dev the current tick, passed to avoid sloads\n        int24 tick;\n        uint32 _blockTimestamp;\n        int24 tickSpacing;\n        uint128 maxLiquidityPerTick;\n    }\n\n    /// @dev to avoid stack-too-deep errors\n    struct UpdatePositionCache {\n        uint256 period;\n        bytes32 _positionHash;\n        uint256 _feeGrowthGlobal0X128;\n        uint256 _feeGrowthGlobal1X128;\n        int24 currentTick;\n        bool flippedLower;\n        bool flippedUpper;\n        int56 tickCumulative;\n        uint160 secondsPerLiquidityCumulativeX128;\n    }\n\n    /// @dev Gets and updates a position with the given liquidity delta\n    /// @param params the position details and the change to the position's liquidity to effect\n    function _updatePosition(UpdatePositionParams memory params) external returns (PositionInfo storage position) {\n        PoolStorage.PoolState storage $ = PoolStorage.getStorage();\n\n        UpdatePositionCache memory cache = UpdatePositionCache({\n            /// @dev calculate the period once, and reuse it\n            period: params._blockTimestamp / 1 weeks,\n            /// @dev precompute the position hash\n            _positionHash: positionHash(params.owner, params.index, params.tickLower, params.tickUpper),\n            /// @dev SLOAD for gas optimization\n            _feeGrowthGlobal0X128: $.feeGrowthGlobal0X128,\n            _feeGrowthGlobal1X128: $.feeGrowthGlobal1X128,\n            /// @dev use the tick from `$.slot0` instead of `params.tick` for consistency\n            currentTick: $.slot0.tick,\n            flippedLower: false,\n            flippedUpper: false,\n            tickCumulative: 0,\n            secondsPerLiquidityCumulativeX128: 0\n        });\n\n        /// @dev fetch the position using the precomputed _positionHash\n        position = $.positions[cache._positionHash];\n\n        /// @dev check and update ticks if needed\n        if (params.liquidityDelta != 0) {\n            /// @dev directly use params._blockTimestamp instead of creating a new `time` variable\n            (cache.tickCumulative, cache.secondsPerLiquidityCumulativeX128) = Oracle.observeSingle(\n                $.observations,\n                params._blockTimestamp,\n                0,\n                cache.currentTick,\n                /// @dev use `currentTick` consistently\n                $.slot0.observationIndex,\n                $.liquidity,\n                $.slot0.observationCardinality\n            );\n\n            cache.flippedLower = Tick.update(\n                $._ticks,\n                params.tickLower,\n                /// @dev use `currentTick` consistently\n                cache.currentTick,\n                params.liquidityDelta,\n                cache._feeGrowthGlobal0X128,\n                cache._feeGrowthGlobal1X128,\n                cache.secondsPerLiquidityCumulativeX128,\n                cache.tickCumulative,\n                params._blockTimestamp,\n                false,\n                params.maxLiquidityPerTick\n            );\n            cache.flippedUpper = Tick.update(\n                $._ticks,\n                params.tickUpper,\n                /// @dev use `currentTick` consistently\n                cache.currentTick,\n                params.liquidityDelta,\n                cache._feeGrowthGlobal0X128,\n                cache._feeGrowthGlobal1X128,\n                cache.secondsPerLiquidityCumulativeX128,\n                cache.tickCumulative,\n                params._blockTimestamp,\n                true,\n                params.maxLiquidityPerTick\n            );\n\n            /// @dev flip ticks if needed\n            if (cache.flippedLower) {\n                TickBitmap.flipTick($.tickBitmap, params.tickLower, params.tickSpacing);\n            }\n            if (cache.flippedUpper) {\n                TickBitmap.flipTick($.tickBitmap, params.tickUpper, params.tickSpacing);\n            }\n        }\n\n        /// @dev calculate the fee growth inside\n        (uint256 feeGrowthInside0X128, uint256 feeGrowthInside1X128) = Tick.getFeeGrowthInside(\n            $._ticks,\n            params.tickLower,\n            params.tickUpper,\n            cache.currentTick,\n            /// @dev use `currentTick` consistently\n            cache._feeGrowthGlobal0X128,\n            cache._feeGrowthGlobal1X128\n        );\n\n        /// @dev get the seconds per liquidity period cumulatives\n        uint160 secondsPerLiquidityPeriodX128 = Oracle.periodCumulativesInside(\n            uint32(cache.period), params.tickLower, params.tickUpper, params._blockTimestamp\n        );\n\n        /// @dev initialize position reward info if needed\n        if (!position.periodRewardInfo[cache.period].initialized || position.liquidity == 0) {\n            initializeSecondsStart(\n                position,\n                PositionPeriodSecondsInRangeParams({\n                    period: cache.period,\n                    owner: params.owner,\n                    index: params.index,\n                    tickLower: params.tickLower,\n                    tickUpper: params.tickUpper,\n                    _blockTimestamp: params._blockTimestamp\n                }),\n                secondsPerLiquidityPeriodX128\n            );\n        }\n\n        /// @dev update the position\n        update(\n            position,\n            params.liquidityDelta,\n            feeGrowthInside0X128,\n            feeGrowthInside1X128,\n            cache._positionHash,\n            cache.period,\n            secondsPerLiquidityPeriodX128\n        );\n\n        /// @dev clear tick data if liquidity delta is negative and the ticks no longer hold liquidity\n        if (params.liquidityDelta < 0) {\n            if (cache.flippedLower) {\n                Tick.clear($._ticks, params.tickLower, cache.period);\n            }\n            if (cache.flippedUpper) {\n                Tick.clear($._ticks, params.tickUpper, cache.period);\n            }\n        }\n    }\n\n    /// @notice Initializes secondsPerLiquidityPeriodStartX128 for a position\n    /// @param position The individual position\n    /// @param secondsInRangeParams Parameters used to find the seconds in range\n    /// @param secondsPerLiquidityPeriodX128 The seconds in range gained per unit of liquidity, inside the position's tick boundaries for this period\n    function initializeSecondsStart(\n        PositionInfo storage position,\n        PositionPeriodSecondsInRangeParams memory secondsInRangeParams,\n        uint160 secondsPerLiquidityPeriodX128\n    ) internal {\n        /// @dev record initialized\n        position.periodRewardInfo[secondsInRangeParams.period].initialized = true;\n\n        /// @dev record owed tokens if liquidity > 0 (means position existed before period change)\n        if (position.liquidity > 0) {\n            uint256 periodSecondsInsideX96 = positionPeriodSecondsInRange(secondsInRangeParams);\n\n            position.periodRewardInfo[secondsInRangeParams.period].secondsDebtX96 = -int256(periodSecondsInsideX96);\n        }\n\n        /// @dev convert uint to int\n        /// @dev negative expected sometimes, which is allowed\n        int160 secondsPerLiquidityPeriodIntX128 = int160(secondsPerLiquidityPeriodX128);\n\n        position.periodRewardInfo[secondsInRangeParams.period].secondsPerLiquidityPeriodStartX128 =\n            secondsPerLiquidityPeriodIntX128;\n    }\n}\n"
        },
        "contracts/CL/core/libraries/Oracle.sol": {
            "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity ^0.8.0;\n\nimport {PoolStorage, Observation, TickInfo, Slot0} from './PoolStorage.sol';\n\n/// @title Oracle\n/// @notice Provides price and liquidity data useful for a wide variety of system designs\n/// @dev Instances of stored oracle data, \"observations\", are collected in the oracle array\n/// Every pool is initialized with an oracle array length of 1. Anyone can pay the SSTOREs to increase the\n/// maximum length of the oracle array. New slots will be added when the array is fully populated.\n/// Observations are overwritten when the full length of the oracle array is populated.\n/// The most recent observation is available, independent of the length of the oracle array, by passing 0 to observe()\nlibrary Oracle {\n    error I();\n    error OLD();\n\n    /// @notice Transforms a previous observation into a new observation, given the passage of time and the current tick and liquidity values\n    /// @dev blockTimestamp _must_ be chronologically equal to or greater than last.blockTimestamp, safe for 0 or 1 overflows\n    /// @param last The specified observation to be transformed\n    /// @param blockTimestamp The timestamp of the new observation\n    /// @param tick The active tick at the time of the new observation\n    /// @param liquidity The total in-range liquidity at the time of the new observation\n    /// @return Observation The newly populated observation\n    function transform(\n        Observation memory last,\n        uint32 blockTimestamp,\n        int24 tick,\n        uint128 liquidity\n    ) private pure returns (Observation memory) {\n        unchecked {\n            uint32 delta = blockTimestamp - last.blockTimestamp;\n            return\n                Observation({\n                    blockTimestamp: blockTimestamp,\n                    tickCumulative: last.tickCumulative + int56(tick) * int56(uint56(delta)),\n                    secondsPerLiquidityCumulativeX128: last.secondsPerLiquidityCumulativeX128 +\n                        ((uint160(delta) << 128) / (liquidity > 0 ? liquidity : 1)),\n                    initialized: true\n                });\n        }\n    }\n\n    /// @notice Initialize the oracle array by writing the first slot. Called once for the lifecycle of the observations array\n    /// @param self The stored oracle array\n    /// @param time The time of the oracle initialization, via block.timestamp truncated to uint32\n    /// @return cardinality The number of populated elements in the oracle array\n    /// @return cardinalityNext The new length of the oracle array, independent of population\n    function initialize(\n        Observation[65535] storage self,\n        uint32 time\n    ) internal returns (uint16 cardinality, uint16 cardinalityNext) {\n        self[0] = Observation({\n            blockTimestamp: time,\n            tickCumulative: 0,\n            secondsPerLiquidityCumulativeX128: 0,\n            initialized: true\n        });\n        return (1, 1);\n    }\n\n    /// @notice Writes an oracle observation to the array\n    /// @dev Writable at most once per block. Index represents the most recently written element. cardinality and index must be tracked externally.\n    /// If the index is at the end of the allowable array length (according to cardinality), and the next cardinality\n    /// is greater than the current one, cardinality may be increased. This restriction is created to preserve ordering.\n    /// @param self The stored oracle array\n    /// @param index The index of the observation that was most recently written to the observations array\n    /// @param blockTimestamp The timestamp of the new observation\n    /// @param tick The active tick at the time of the new observation\n    /// @param liquidity The total in-range liquidity at the time of the new observation\n    /// @param cardinality The number of populated elements in the oracle array\n    /// @param cardinalityNext The new length of the oracle array, independent of population\n    /// @return indexUpdated The new index of the most recently written element in the oracle array\n    /// @return cardinalityUpdated The new cardinality of the oracle array\n    function write(\n        Observation[65535] storage self,\n        uint16 index,\n        uint32 blockTimestamp,\n        int24 tick,\n        uint128 liquidity,\n        uint16 cardinality,\n        uint16 cardinalityNext\n    ) internal returns (uint16 indexUpdated, uint16 cardinalityUpdated) {\n        unchecked {\n            Observation memory last = self[index];\n\n            /// @dev early return if we've already written an observation this block\n            if (last.blockTimestamp == blockTimestamp) return (index, cardinality);\n\n            /// @dev if the conditions are right, we can bump the cardinality\n            if (cardinalityNext > cardinality && index == (cardinality - 1)) {\n                cardinalityUpdated = cardinalityNext;\n            } else {\n                cardinalityUpdated = cardinality;\n            }\n\n            indexUpdated = (index + 1) % cardinalityUpdated;\n            self[indexUpdated] = transform(last, blockTimestamp, tick, liquidity);\n        }\n    }\n\n    /// @notice Prepares the oracle array to store up to `next` observations\n    /// @param self The stored oracle array\n    /// @param current The current next cardinality of the oracle array\n    /// @param next The proposed next cardinality which will be populated in the oracle array\n    /// @return next The next cardinality which will be populated in the oracle array\n    function grow(Observation[65535] storage self, uint16 current, uint16 next) internal returns (uint16) {\n        unchecked {\n            if (current <= 0) revert I();\n            /// @dev no-op if the passed next value isn't greater than the current next value\n            if (next <= current) return current;\n            /// @dev store in each slot to prevent fresh SSTOREs in swaps\n            /// @dev this data will not be used because the initialized boolean is still false\n            for (uint16 i = current; i < next; i++) self[i].blockTimestamp = 1;\n            return next;\n        }\n    }\n\n    /// @notice comparator for 32-bit timestamps\n    /// @dev safe for 0 or 1 overflows, a and b _must_ be chronologically before or equal to time\n    /// @param time A timestamp truncated to 32 bits\n    /// @param a A comparison timestamp from which to determine the relative position of `time`\n    /// @param b From which to determine the relative position of `time`\n    /// @return Whether `a` is chronologically <= `b`\n    function lte(uint32 time, uint32 a, uint32 b) private pure returns (bool) {\n        unchecked {\n            /// @dev if there hasn't been overflow, no need to adjust\n            if (a <= time && b <= time) return a <= b;\n\n            uint256 aAdjusted = a > time ? a : a + 2 ** 32;\n            uint256 bAdjusted = b > time ? b : b + 2 ** 32;\n\n            return aAdjusted <= bAdjusted;\n        }\n    }\n\n    /// @notice Fetches the observations beforeOrAt and atOrAfter a target, i.e. where [beforeOrAt, atOrAfter] is satisfied.\n    /// The result may be the same observation, or adjacent observations.\n    /// @dev The answer must be contained in the array, used when the target is located within the stored observation\n    /// boundaries: older than the most recent observation and younger, or the same age as, the oldest observation\n    /// @param self The stored oracle array\n    /// @param time The current block.timestamp\n    /// @param target The timestamp at which the reserved observation should be for\n    /// @param index The index of the observation that was most recently written to the observations array\n    /// @param cardinality The number of populated elements in the oracle array\n    /// @return beforeOrAt The observation recorded before, or at, the target\n    /// @return atOrAfter The observation recorded at, or after, the target\n    function binarySearch(\n        Observation[65535] storage self,\n        uint32 time,\n        uint32 target,\n        uint16 index,\n        uint16 cardinality\n    ) private view returns (Observation memory beforeOrAt, Observation memory atOrAfter) {\n        unchecked {\n            /// @dev oldest observation\n            uint256 l = (index + 1) % cardinality; \n            /// @dev newest observation\n            uint256 r = l + cardinality - 1; \n            uint256 i;\n            while (true) {\n                i = (l + r) / 2;\n\n                beforeOrAt = self[i % cardinality];\n\n                /// @dev we've landed on an uninitialized tick, keep searching higher (more recently)\n                if (!beforeOrAt.initialized) {\n                    l = i + 1;\n                    continue;\n                }\n\n                atOrAfter = self[(i + 1) % cardinality];\n\n                bool targetAtOrAfter = lte(time, beforeOrAt.blockTimestamp, target);\n\n                /// @dev check if we've found the answer!\n                if (targetAtOrAfter && lte(time, target, atOrAfter.blockTimestamp)) break;\n\n                if (!targetAtOrAfter) r = i - 1;\n                else l = i + 1;\n            }\n        }\n    }\n\n    /// @notice Fetches the observations beforeOrAt and atOrAfter a given target, i.e. where [beforeOrAt, atOrAfter] is satisfied\n    /// @dev Assumes there is at least 1 initialized observation.\n    /// Used by observeSingle() to compute the counterfactual accumulator values as of a given block timestamp.\n    /// @param self The stored oracle array\n    /// @param time The current block.timestamp\n    /// @param target The timestamp at which the reserved observation should be for\n    /// @param tick The active tick at the time of the returned or simulated observation\n    /// @param index The index of the observation that was most recently written to the observations array\n    /// @param liquidity The total pool liquidity at the time of the call\n    /// @param cardinality The number of populated elements in the oracle array\n    /// @return beforeOrAt The observation which occurred at, or before, the given timestamp\n    /// @return atOrAfter The observation which occurred at, or after, the given timestamp\n    function getSurroundingObservations(\n        Observation[65535] storage self,\n        uint32 time,\n        uint32 target,\n        int24 tick,\n        uint16 index,\n        uint128 liquidity,\n        uint16 cardinality\n    ) private view returns (Observation memory beforeOrAt, Observation memory atOrAfter) {\n        unchecked {\n            /// @dev optimistically set before to the newest observation\n            beforeOrAt = self[index];\n\n            /// @dev if the target is chronologically at or after the newest observation, we can early return\n            if (lte(time, beforeOrAt.blockTimestamp, target)) {\n                if (beforeOrAt.blockTimestamp == target) {\n                    /// @dev if newest observation equals target, we're in the same block, so we can ignore atOrAfter\n                    return (beforeOrAt, atOrAfter);\n                } else {\n                    /// @dev otherwise, we need to transform\n                    return (beforeOrAt, transform(beforeOrAt, target, tick, liquidity));\n                }\n            }\n\n            /// @dev now, set before to the oldest observation\n            beforeOrAt = self[(index + 1) % cardinality];\n            if (!beforeOrAt.initialized) beforeOrAt = self[0];\n\n            /// @dev ensure that the target is chronologically at or after the oldest observation\n            if (!lte(time, beforeOrAt.blockTimestamp, target)) revert OLD();\n\n            /// @dev if we've reached this point, we have to binary search\n            return binarySearch(self, time, target, index, cardinality);\n        }\n    }\n\n    /// @dev Reverts if an observation at or before the desired observation timestamp does not exist.\n    /// 0 may be passed as `secondsAgo' to return the current cumulative values.\n    /// If called with a timestamp falling between two observations, returns the counterfactual accumulator values\n    /// at exactly the timestamp between the two observations.\n    /// @param self The stored oracle array\n    /// @param time The current block timestamp\n    /// @param secondsAgo The amount of time to look back, in seconds, at which point to return an observation\n    /// @param tick The current tick\n    /// @param index The index of the observation that was most recently written to the observations array\n    /// @param liquidity The current in-range pool liquidity\n    /// @param cardinality The number of populated elements in the oracle array\n    /// @return tickCumulative The tick * time elapsed since the pool was first initialized, as of `secondsAgo`\n    /// @return secondsPerLiquidityCumulativeX128 The time elapsed / max(1, liquidity) since the pool was first initialized, as of `secondsAgo`\n    function observeSingle(\n        Observation[65535] storage self,\n        uint32 time,\n        uint32 secondsAgo,\n        int24 tick,\n        uint16 index,\n        uint128 liquidity,\n        uint16 cardinality\n    ) internal view returns (int56 tickCumulative, uint160 secondsPerLiquidityCumulativeX128) {\n        unchecked {\n            if (secondsAgo == 0) {\n                Observation memory last = self[index];\n                if (last.blockTimestamp != time) last = transform(last, time, tick, liquidity);\n                return (last.tickCumulative, last.secondsPerLiquidityCumulativeX128);\n            }\n\n            uint32 target = time - secondsAgo;\n\n            (Observation memory beforeOrAt, Observation memory atOrAfter) = getSurroundingObservations(\n                self,\n                time,\n                target,\n                tick,\n                index,\n                liquidity,\n                cardinality\n            );\n\n            if (target == beforeOrAt.blockTimestamp) {\n                /// @dev we're at the left boundary\n                return (beforeOrAt.tickCumulative, beforeOrAt.secondsPerLiquidityCumulativeX128);\n            } else if (target == atOrAfter.blockTimestamp) {\n                /// @dev we're at the right boundary\n                return (atOrAfter.tickCumulative, atOrAfter.secondsPerLiquidityCumulativeX128);\n            } else {\n                /// @dev we're in the middle\n                uint32 observationTimeDelta = atOrAfter.blockTimestamp - beforeOrAt.blockTimestamp;\n                uint32 targetDelta = target - beforeOrAt.blockTimestamp;\n                return (\n                    beforeOrAt.tickCumulative +\n                        ((atOrAfter.tickCumulative - beforeOrAt.tickCumulative) / int56(uint56(observationTimeDelta))) *\n                        int56(uint56(targetDelta)),\n                    beforeOrAt.secondsPerLiquidityCumulativeX128 +\n                        uint160(\n                            (uint256(\n                                atOrAfter.secondsPerLiquidityCumulativeX128 -\n                                    beforeOrAt.secondsPerLiquidityCumulativeX128\n                            ) * targetDelta) / observationTimeDelta\n                        )\n                );\n            }\n        }\n    }\n\n    /// @notice Returns the accumulator values as of each time seconds ago from the given time in the array of `secondsAgos`\n    /// @dev Reverts if `secondsAgos` > oldest observation\n    /// @param self The stored oracle array\n    /// @param time The current block.timestamp\n    /// @param secondsAgos Each amount of time to look back, in seconds, at which point to return an observation\n    /// @param tick The current tick\n    /// @param index The index of the observation that was most recently written to the observations array\n    /// @param liquidity The current in-range pool liquidity\n    /// @param cardinality The number of populated elements in the oracle array\n    /// @return tickCumulatives The tick * time elapsed since the pool was first initialized, as of each `secondsAgo`\n    /// @return secondsPerLiquidityCumulativeX128s The cumulative seconds / max(1, liquidity) since the pool was first initialized, as of each `secondsAgo`\n    function observe(\n        Observation[65535] storage self,\n        uint32 time,\n        uint32[] memory secondsAgos,\n        int24 tick,\n        uint16 index,\n        uint128 liquidity,\n        uint16 cardinality\n    ) internal view returns (int56[] memory tickCumulatives, uint160[] memory secondsPerLiquidityCumulativeX128s) {\n        unchecked {\n            if (cardinality <= 0) revert I();\n\n            tickCumulatives = new int56[](secondsAgos.length);\n            secondsPerLiquidityCumulativeX128s = new uint160[](secondsAgos.length);\n            for (uint256 i = 0; i < secondsAgos.length; i++) {\n                (tickCumulatives[i], secondsPerLiquidityCumulativeX128s[i]) = observeSingle(\n                    self,\n                    time,\n                    secondsAgos[i],\n                    tick,\n                    index,\n                    liquidity,\n                    cardinality\n                );\n            }\n        }\n    }\n\n    function newPeriod(\n        Observation[65535] storage self,\n        uint16 index,\n        uint256 period\n    ) external returns (uint160 secondsPerLiquidityCumulativeX128) {\n        Observation memory last = self[index];\n        PoolStorage.PoolState storage $ = PoolStorage.getStorage();\n\n        unchecked {\n            uint32 delta = uint32(period) * 1 weeks - 1 - last.blockTimestamp;\n\n            secondsPerLiquidityCumulativeX128 =\n                last.secondsPerLiquidityCumulativeX128 +\n                ((uint160(delta) << 128) / ($.liquidity > 0 ? $.liquidity : 1));\n\n            self[index] = Observation({\n                blockTimestamp: uint32(period) * 1 weeks - 1,\n                tickCumulative: last.tickCumulative + int56($.slot0.tick) * int56(uint56(delta)),\n                secondsPerLiquidityCumulativeX128: secondsPerLiquidityCumulativeX128,\n                initialized: last.initialized\n            });\n        }\n    }\n\n    struct SnapShot {\n        int56 tickCumulativeLower;\n        int56 tickCumulativeUpper;\n        uint160 secondsPerLiquidityOutsideLowerX128;\n        uint160 secondsPerLiquidityOutsideUpperX128;\n        uint32 secondsOutsideLower;\n        uint32 secondsOutsideUpper;\n    }\n\n    struct SnapshotCumulativesInsideCache {\n        uint32 time;\n        int56 tickCumulative;\n        uint160 secondsPerLiquidityCumulativeX128;\n    }\n\n    /// @notice Returns a snapshot of the tick cumulative, seconds per liquidity and seconds inside a tick range\n    /// @dev Snapshots must only be compared to other snapshots, taken over a period for which a position existed.\n    /// I.e., snapshots cannot be compared if a position is not held for the entire period between when the first\n    /// snapshot is taken and the second snapshot is taken. Boosted data is only valid if it's within the same period\n    /// @param tickLower The lower tick of the range\n    /// @param tickUpper The upper tick of the range\n    /// @return tickCumulativeInside The snapshot of the tick accumulator for the range\n    /// @return secondsPerLiquidityInsideX128 The snapshot of seconds per liquidity for the range\n    /// @return secondsInside The snapshot of seconds per liquidity for the range\n    function snapshotCumulativesInside(\n        int24 tickLower,\n        int24 tickUpper,\n        uint32 _blockTimestamp\n    ) external view returns (int56 tickCumulativeInside, uint160 secondsPerLiquidityInsideX128, uint32 secondsInside) {\n        PoolStorage.PoolState storage $ = PoolStorage.getStorage();\n\n        TickInfo storage lower = $._ticks[tickLower];\n        TickInfo storage upper = $._ticks[tickUpper];\n\n        SnapShot memory snapshot;\n\n        bool initializedLower;\n        (\n            snapshot.tickCumulativeLower,\n            snapshot.secondsPerLiquidityOutsideLowerX128,\n            snapshot.secondsOutsideLower,\n            initializedLower\n        ) = (\n            lower.tickCumulativeOutside,\n            lower.secondsPerLiquidityOutsideX128,\n            lower.secondsOutside,\n            lower.initialized\n        );\n        require(initializedLower);\n\n        bool initializedUpper;\n        (\n            snapshot.tickCumulativeUpper,\n            snapshot.secondsPerLiquidityOutsideUpperX128,\n            snapshot.secondsOutsideUpper,\n            initializedUpper\n        ) = (\n            upper.tickCumulativeOutside,\n            upper.secondsPerLiquidityOutsideX128,\n            upper.secondsOutside,\n            upper.initialized\n        );\n        require(initializedUpper);\n\n        Slot0 memory _slot0 = $.slot0;\n\n        unchecked {\n            if (_slot0.tick < tickLower) {\n                return (\n                    snapshot.tickCumulativeLower - snapshot.tickCumulativeUpper,\n                    snapshot.secondsPerLiquidityOutsideLowerX128 - snapshot.secondsPerLiquidityOutsideUpperX128,\n                    snapshot.secondsOutsideLower - snapshot.secondsOutsideUpper\n                );\n            } else if (_slot0.tick < tickUpper) {\n                SnapshotCumulativesInsideCache memory cache;\n                cache.time = _blockTimestamp;\n                (cache.tickCumulative, cache.secondsPerLiquidityCumulativeX128) = observeSingle(\n                    $.observations,\n                    cache.time,\n                    0,\n                    _slot0.tick,\n                    _slot0.observationIndex,\n                    $.liquidity,\n                    _slot0.observationCardinality\n                );\n                return (\n                    cache.tickCumulative - snapshot.tickCumulativeLower - snapshot.tickCumulativeUpper,\n                    cache.secondsPerLiquidityCumulativeX128 -\n                        snapshot.secondsPerLiquidityOutsideLowerX128 -\n                        snapshot.secondsPerLiquidityOutsideUpperX128,\n                    cache.time - snapshot.secondsOutsideLower - snapshot.secondsOutsideUpper\n                );\n            } else {\n                return (\n                    snapshot.tickCumulativeUpper - snapshot.tickCumulativeLower,\n                    snapshot.secondsPerLiquidityOutsideUpperX128 - snapshot.secondsPerLiquidityOutsideLowerX128,\n                    snapshot.secondsOutsideUpper - snapshot.secondsOutsideLower\n                );\n            }\n        }\n    }\n\n    /// @notice Returns the seconds per liquidity and seconds inside a tick range for a period\n    /// @dev This does not ensure the range is a valid range\n    /// @param period The timestamp of the period\n    /// @param tickLower The lower tick of the range\n    /// @param tickUpper The upper tick of the range\n    /// @return secondsPerLiquidityInsideX128 The snapshot of seconds per liquidity for the range\n    function periodCumulativesInside(\n        uint32 period,\n        int24 tickLower,\n        int24 tickUpper,\n        uint32 _blockTimestamp\n    ) external view returns (uint160 secondsPerLiquidityInsideX128) {\n        PoolStorage.PoolState storage $ = PoolStorage.getStorage();\n\n        TickInfo storage lower = $._ticks[tickLower];\n        TickInfo storage upper = $._ticks[tickUpper];\n\n        SnapShot memory snapshot;\n\n        {\n            int24 startTick = $.periods[period].startTick;\n            uint256 previousPeriod = $.periods[period].previousPeriod;\n\n            snapshot.secondsPerLiquidityOutsideLowerX128 = uint160(lower.periodSecondsPerLiquidityOutsideX128[period]);\n\n            if (tickLower <= startTick && snapshot.secondsPerLiquidityOutsideLowerX128 == 0) {\n                snapshot.secondsPerLiquidityOutsideLowerX128 = $\n                    .periods[previousPeriod]\n                    .endSecondsPerLiquidityPeriodX128;\n            }\n\n            snapshot.secondsPerLiquidityOutsideUpperX128 = uint160(upper.periodSecondsPerLiquidityOutsideX128[period]);\n            if (tickUpper <= startTick && snapshot.secondsPerLiquidityOutsideUpperX128 == 0) {\n                snapshot.secondsPerLiquidityOutsideUpperX128 = $\n                    .periods[previousPeriod]\n                    .endSecondsPerLiquidityPeriodX128;\n            }\n        }\n\n        int24 lastTick;\n        uint256 currentPeriod = $.lastPeriod;\n        {\n            /// @dev if period is already finalized, use period's last tick, if not, use current tick\n            if (currentPeriod > period) {\n                lastTick = $.periods[period].lastTick;\n            } else {\n                lastTick = $.slot0.tick;\n            }\n        }\n\n        unchecked {\n            if (lastTick < tickLower) {\n                return snapshot.secondsPerLiquidityOutsideLowerX128 - snapshot.secondsPerLiquidityOutsideUpperX128;\n            } else if (lastTick < tickUpper) {\n                SnapshotCumulativesInsideCache memory cache;\n                /// @dev if period's on-going, observeSingle, if finalized, use endSecondsPerLiquidityPeriodX128\n                if (currentPeriod <= period) {\n                    cache.time = _blockTimestamp;\n                    /// @dev limit to the end of period\n                    if (cache.time >= currentPeriod * 1 weeks + 1 weeks) {\n                        cache.time = uint32(currentPeriod * 1 weeks + 1 weeks - 1);\n                    }\n\n                    Slot0 memory _slot0 = $.slot0;\n\n                    (, cache.secondsPerLiquidityCumulativeX128) = observeSingle(\n                        $.observations,\n                        cache.time,\n                        0,\n                        _slot0.tick,\n                        _slot0.observationIndex,\n                        $.liquidity,\n                        _slot0.observationCardinality\n                    );\n                } else {\n                    cache.secondsPerLiquidityCumulativeX128 = $.periods[period].endSecondsPerLiquidityPeriodX128;\n                }\n                return\n                    cache.secondsPerLiquidityCumulativeX128 -\n                    snapshot.secondsPerLiquidityOutsideLowerX128 -\n                    snapshot.secondsPerLiquidityOutsideUpperX128;\n            } else {\n                return snapshot.secondsPerLiquidityOutsideUpperX128 - snapshot.secondsPerLiquidityOutsideLowerX128;\n            }\n        }\n    }\n}\n"
        },
        "contracts/CL/core/libraries/FullMath.sol": {
            "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/// @title Contains 512-bit math functions\n/// @notice Facilitates multiplication and division that can have overflow of an intermediate value without any loss of precision\n/// @dev Handles \"phantom overflow\" i.e., allows multiplication and division where an intermediate value overflows 256 bits\nlibrary FullMath {\n    /// @notice Calculates floor(abdenominator) with full precision. Throws if result overflows a uint256 or denominator == 0\n    /// @param a The multiplicand\n    /// @param b The multiplier\n    /// @param denominator The divisor\n    /// @return result The 256-bit result\n    /// @dev Credit to Remco Bloemen under MIT license https://xn--2-umb.com/21/muldiv\n    function mulDiv(uint256 a, uint256 b, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            // 512-bit multiply [prod1 prod0] = a * b\n            // Compute the product mod 2**256 and mod 2**256 - 1\n            // then use the Chinese Remainder Theorem to reconstruct\n            // the 512 bit result. The result is stored in two 256\n            // variables such that product = prod1 * 2**256 + prod0\n            uint256 prod0; // Least significant 256 bits of the product\n            uint256 prod1; // Most significant 256 bits of the product\n            assembly {\n                let mm := mulmod(a, b, not(0))\n                prod0 := mul(a, b)\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n\n            // Handle non-overflow cases, 256 by 256 division\n            if (prod1 == 0) {\n                require(denominator > 0);\n                assembly {\n                    result := div(prod0, denominator)\n                }\n                return result;\n            }\n\n            // Make sure the result is less than 2**256.\n            // Also prevents denominator == 0\n            require(denominator > prod1);\n\n            ///////////////////////////////////////////////\n            // 512 by 256 division.\n            ///////////////////////////////////////////////\n\n            // Make division exact by subtracting the remainder from [prod1 prod0]\n            // Compute remainder using mulmod\n            uint256 remainder;\n            assembly {\n                remainder := mulmod(a, b, denominator)\n            }\n            // Subtract 256 bit number from 512 bit number\n            assembly {\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n\n            // Factor powers of two out of denominator\n            // Compute largest power of two divisor of denominator.\n            // Always >= 1.\n            uint256 twos = (0 - denominator) & denominator;\n            // Divide denominator by power of two\n            assembly {\n                denominator := div(denominator, twos)\n            }\n\n            // Divide [prod1 prod0] by the factors of two\n            assembly {\n                prod0 := div(prod0, twos)\n            }\n            // Shift in bits from prod1 into prod0. For this we need\n            // to flip `twos` such that it is 2**256 / twos.\n            // If twos is zero, then it becomes one\n            assembly {\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n            prod0 |= prod1 * twos;\n\n            // Invert denominator mod 2**256\n            // Now that denominator is an odd number, it has an inverse\n            // modulo 2**256 such that denominator * inv = 1 mod 2**256.\n            // Compute the inverse by starting with a seed that is correct\n            // correct for four bits. That is, denominator * inv = 1 mod 2**4\n            uint256 inv = (3 * denominator) ^ 2;\n            // Now use Newton-Raphson iteration to improve the precision.\n            // Thanks to Hensel's lifting lemma, this also works in modular\n            // arithmetic, doubling the correct bits in each step.\n            inv *= 2 - denominator * inv; // inverse mod 2**8\n            inv *= 2 - denominator * inv; // inverse mod 2**16\n            inv *= 2 - denominator * inv; // inverse mod 2**32\n            inv *= 2 - denominator * inv; // inverse mod 2**64\n            inv *= 2 - denominator * inv; // inverse mod 2**128\n            inv *= 2 - denominator * inv; // inverse mod 2**256\n\n            // Because the division is now exact we can divide by multiplying\n            // with the modular inverse of denominator. This will give us the\n            // correct result modulo 2**256. Since the precoditions guarantee\n            // that the outcome is less than 2**256, this is the final result.\n            // We don't need to compute the high bits of the result and prod1\n            // is no longer required.\n            result = prod0 * inv;\n            return result;\n        }\n    }\n\n    /// @notice Calculates ceil(abdenominator) with full precision. Throws if result overflows a uint256 or denominator == 0\n    /// @param a The multiplicand\n    /// @param b The multiplier\n    /// @param denominator The divisor\n    /// @return result The 256-bit result\n    function mulDivRoundingUp(uint256 a, uint256 b, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            result = mulDiv(a, b, denominator);\n            if (mulmod(a, b, denominator) > 0) {\n                require(result < type(uint256).max);\n                result++;\n            }\n        }\n    }\n}\n"
        },
        "contracts/CL/core/libraries/FixedPoint128.sol": {
            "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.4.0;\n\n/// @title FixedPoint128\n/// @notice A library for handling binary fixed point numbers, see https://en.wikipedia.org/wiki/Q_(number_format)\nlibrary FixedPoint128 {\n    uint256 internal constant Q128 = 0x100000000000000000000000000000000;\n}\n"
        },
        "contracts/CL/core/libraries/TransferHelper.sol": {
            "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.6.0;\n\nimport {IERC20Minimal} from '../interfaces/IERC20Minimal.sol';\n\n/// @title TransferHelper\n/// @notice Contains helper methods for interacting with ERC20 tokens that do not consistently return true/false\nlibrary TransferHelper {\n    error TF();\n\n    /// @notice Transfers tokens from msg.sender to a recipient\n    /// @dev Calls transfer on token contract, errors with TF if transfer fails\n    /// @param token The contract address of the token which will be transferred\n    /// @param to The recipient of the transfer\n    /// @param value The value of the transfer\n    function safeTransfer(address token, address to, uint256 value) internal {\n        (bool success, bytes memory data) = token.call(\n            abi.encodeWithSelector(IERC20Minimal.transfer.selector, to, value)\n        );\n        if (!(success && (data.length == 0 || abi.decode(data, (bool))))) revert TF();\n    }\n}\n"
        },
        "contracts/CL/core/libraries/TickMath.sol": {
            "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity ^0.8.0;\n\n/// @title Math library for computing sqrt prices from ticks and vice versa\n/// @notice Computes sqrt price for ticks of size 1.0001, i.e. sqrt(1.0001^tick) as fixed point Q64.96 numbers. Supports\n/// prices between 2**-128 and 2**128\nlibrary TickMath {\n    error T();\n    error R();\n\n    /// @dev The minimum tick that may be passed to #getSqrtRatioAtTick computed from log base 1.0001 of 2**-128\n    int24 internal constant MIN_TICK = -887272;\n    /// @dev The maximum tick that may be passed to #getSqrtRatioAtTick computed from log base 1.0001 of 2**128\n    int24 internal constant MAX_TICK = -MIN_TICK;\n\n    /// @dev The minimum value that can be returned from #getSqrtRatioAtTick. Equivalent to getSqrtRatioAtTick(MIN_TICK)\n    uint160 internal constant MIN_SQRT_RATIO = 4295128739;\n    /// @dev The maximum value that can be returned from #getSqrtRatioAtTick. Equivalent to getSqrtRatioAtTick(MAX_TICK)\n    uint160 internal constant MAX_SQRT_RATIO = 1461446703485210103287273052203988822378723970342;\n\n    /// @notice Calculates sqrt(1.0001^tick) * 2^96\n    /// @dev Throws if |tick| > max tick\n    /// @param tick The input tick for the above formula\n    /// @return sqrtPriceX96 A Fixed point Q64.96 number representing the sqrt of the ratio of the two assets (token1/token0)\n    /// at the given tick\n    function getSqrtRatioAtTick(int24 tick) internal pure returns (uint160 sqrtPriceX96) {\n        unchecked {\n            uint256 absTick = tick < 0 ? uint256(-int256(tick)) : uint256(int256(tick));\n            if (absTick > uint256(int256(MAX_TICK))) revert T();\n\n            uint256 ratio = absTick & 0x1 != 0\n                ? 0xfffcb933bd6fad37aa2d162d1a594001\n                : 0x100000000000000000000000000000000;\n            if (absTick & 0x2 != 0) ratio = (ratio * 0xfff97272373d413259a46990580e213a) >> 128;\n            if (absTick & 0x4 != 0) ratio = (ratio * 0xfff2e50f5f656932ef12357cf3c7fdcc) >> 128;\n            if (absTick & 0x8 != 0) ratio = (ratio * 0xffe5caca7e10e4e61c3624eaa0941cd0) >> 128;\n            if (absTick & 0x10 != 0) ratio = (ratio * 0xffcb9843d60f6159c9db58835c926644) >> 128;\n            if (absTick & 0x20 != 0) ratio = (ratio * 0xff973b41fa98c081472e6896dfb254c0) >> 128;\n            if (absTick & 0x40 != 0) ratio = (ratio * 0xff2ea16466c96a3843ec78b326b52861) >> 128;\n            if (absTick & 0x80 != 0) ratio = (ratio * 0xfe5dee046a99a2a811c461f1969c3053) >> 128;\n            if (absTick & 0x100 != 0) ratio = (ratio * 0xfcbe86c7900a88aedcffc83b479aa3a4) >> 128;\n            if (absTick & 0x200 != 0) ratio = (ratio * 0xf987a7253ac413176f2b074cf7815e54) >> 128;\n            if (absTick & 0x400 != 0) ratio = (ratio * 0xf3392b0822b70005940c7a398e4b70f3) >> 128;\n            if (absTick & 0x800 != 0) ratio = (ratio * 0xe7159475a2c29b7443b29c7fa6e889d9) >> 128;\n            if (absTick & 0x1000 != 0) ratio = (ratio * 0xd097f3bdfd2022b8845ad8f792aa5825) >> 128;\n            if (absTick & 0x2000 != 0) ratio = (ratio * 0xa9f746462d870fdf8a65dc1f90e061e5) >> 128;\n            if (absTick & 0x4000 != 0) ratio = (ratio * 0x70d869a156d2a1b890bb3df62baf32f7) >> 128;\n            if (absTick & 0x8000 != 0) ratio = (ratio * 0x31be135f97d08fd981231505542fcfa6) >> 128;\n            if (absTick & 0x10000 != 0) ratio = (ratio * 0x9aa508b5b7a84e1c677de54f3e99bc9) >> 128;\n            if (absTick & 0x20000 != 0) ratio = (ratio * 0x5d6af8dedb81196699c329225ee604) >> 128;\n            if (absTick & 0x40000 != 0) ratio = (ratio * 0x2216e584f5fa1ea926041bedfe98) >> 128;\n            if (absTick & 0x80000 != 0) ratio = (ratio * 0x48a170391f7dc42444e8fa2) >> 128;\n\n            if (tick > 0) ratio = type(uint256).max / ratio;\n\n            /// @dev this divides by 1<<32 rounding up to go from a Q128.128 to a Q128.96.\n            /// @dev we then downcast because we know the result always fits within 160 bits due to our tick input constraint\n            /// @dev we round up in the division so getTickAtSqrtRatio of the output price is always consistent\n            sqrtPriceX96 = uint160((ratio >> 32) + (ratio % (1 << 32) == 0 ? 0 : 1));\n        }\n    }\n\n    /// @notice Calculates the greatest tick value such that getRatioAtTick(tick) <= ratio\n    /// @dev Throws in case sqrtPriceX96 < MIN_SQRT_RATIO, as MIN_SQRT_RATIO is the lowest value getRatioAtTick may\n    /// ever return.\n    /// @param sqrtPriceX96 The sqrt ratio for which to compute the tick as a Q64.96\n    /// @return tick The greatest tick for which the ratio is less than or equal to the input ratio\n    function getTickAtSqrtRatio(uint160 sqrtPriceX96) internal pure returns (int24 tick) {\n        unchecked {\n            /// @dev second inequality must be < because the price can never reach the price at the max tick\n            if (!(sqrtPriceX96 >= MIN_SQRT_RATIO && sqrtPriceX96 < MAX_SQRT_RATIO)) revert R();\n            uint256 ratio = uint256(sqrtPriceX96) << 32;\n\n            uint256 r = ratio;\n            uint256 msb = 0;\n\n            assembly {\n                let f := shl(7, gt(r, 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF))\n                msb := or(msb, f)\n                r := shr(f, r)\n            }\n            assembly {\n                let f := shl(6, gt(r, 0xFFFFFFFFFFFFFFFF))\n                msb := or(msb, f)\n                r := shr(f, r)\n            }\n            assembly {\n                let f := shl(5, gt(r, 0xFFFFFFFF))\n                msb := or(msb, f)\n                r := shr(f, r)\n            }\n            assembly {\n                let f := shl(4, gt(r, 0xFFFF))\n                msb := or(msb, f)\n                r := shr(f, r)\n            }\n            assembly {\n                let f := shl(3, gt(r, 0xFF))\n                msb := or(msb, f)\n                r := shr(f, r)\n            }\n            assembly {\n                let f := shl(2, gt(r, 0xF))\n                msb := or(msb, f)\n                r := shr(f, r)\n            }\n            assembly {\n                let f := shl(1, gt(r, 0x3))\n                msb := or(msb, f)\n                r := shr(f, r)\n            }\n            assembly {\n                let f := gt(r, 0x1)\n                msb := or(msb, f)\n            }\n\n            if (msb >= 128) r = ratio >> (msb - 127);\n            else r = ratio << (127 - msb);\n\n            int256 log_2 = (int256(msb) - 128) << 64;\n\n            assembly {\n                r := shr(127, mul(r, r))\n                let f := shr(128, r)\n                log_2 := or(log_2, shl(63, f))\n                r := shr(f, r)\n            }\n            assembly {\n                r := shr(127, mul(r, r))\n                let f := shr(128, r)\n                log_2 := or(log_2, shl(62, f))\n                r := shr(f, r)\n            }\n            assembly {\n                r := shr(127, mul(r, r))\n                let f := shr(128, r)\n                log_2 := or(log_2, shl(61, f))\n                r := shr(f, r)\n            }\n            assembly {\n                r := shr(127, mul(r, r))\n                let f := shr(128, r)\n                log_2 := or(log_2, shl(60, f))\n                r := shr(f, r)\n            }\n            assembly {\n                r := shr(127, mul(r, r))\n                let f := shr(128, r)\n                log_2 := or(log_2, shl(59, f))\n                r := shr(f, r)\n            }\n            assembly {\n                r := shr(127, mul(r, r))\n                let f := shr(128, r)\n                log_2 := or(log_2, shl(58, f))\n                r := shr(f, r)\n            }\n            assembly {\n                r := shr(127, mul(r, r))\n                let f := shr(128, r)\n                log_2 := or(log_2, shl(57, f))\n                r := shr(f, r)\n            }\n            assembly {\n                r := shr(127, mul(r, r))\n                let f := shr(128, r)\n                log_2 := or(log_2, shl(56, f))\n                r := shr(f, r)\n            }\n            assembly {\n                r := shr(127, mul(r, r))\n                let f := shr(128, r)\n                log_2 := or(log_2, shl(55, f))\n                r := shr(f, r)\n            }\n            assembly {\n                r := shr(127, mul(r, r))\n                let f := shr(128, r)\n                log_2 := or(log_2, shl(54, f))\n                r := shr(f, r)\n            }\n            assembly {\n                r := shr(127, mul(r, r))\n                let f := shr(128, r)\n                log_2 := or(log_2, shl(53, f))\n                r := shr(f, r)\n            }\n            assembly {\n                r := shr(127, mul(r, r))\n                let f := shr(128, r)\n                log_2 := or(log_2, shl(52, f))\n                r := shr(f, r)\n            }\n            assembly {\n                r := shr(127, mul(r, r))\n                let f := shr(128, r)\n                log_2 := or(log_2, shl(51, f))\n                r := shr(f, r)\n            }\n            assembly {\n                r := shr(127, mul(r, r))\n                let f := shr(128, r)\n                log_2 := or(log_2, shl(50, f))\n            }\n\n            int256 log_sqrt10001 = log_2 * 255738958999603826347141; /// @dev 128.128 number\n\n            int24 tickLow = int24((log_sqrt10001 - 3402992956809132418596140100660247210) >> 128);\n            int24 tickHi = int24((log_sqrt10001 + 291339464771989622907027621153398088495) >> 128);\n\n            tick = tickLow == tickHi\n                ? tickLow\n                : getSqrtRatioAtTick(tickHi) <= sqrtPriceX96\n                    ? tickHi\n                    : tickLow;\n        }\n    }\n}\n"
        },
        "contracts/CL/core/libraries/SqrtPriceMath.sol": {
            "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity ^0.8.0;\n\nimport {SafeCast} from './SafeCast.sol';\n\nimport {FullMath} from './FullMath.sol';\nimport {UnsafeMath} from './UnsafeMath.sol';\nimport {FixedPoint96} from './FixedPoint96.sol';\n\n/// @title Functions based on Q64.96 sqrt price and liquidity\n/// @notice Contains the math that uses square root of price as a Q64.96 and liquidity to compute deltas\nlibrary SqrtPriceMath {\n    using SafeCast for uint256;\n\n    /// @notice Gets the next sqrt price given a delta of token0\n    /// @dev Always rounds up, because in the exact output case (increasing price) we need to move the price at least\n    /// far enough to get the desired output amount, and in the exact input case (decreasing price) we need to move the\n    /// price less in order to not send too much output.\n    /// The most precise formula for this is liquidity * sqrtPX96 / (liquidity +- amount * sqrtPX96),\n    /// if this is impossible because of overflow, we calculate liquidity / (liquidity / sqrtPX96 +- amount).\n    /// @param sqrtPX96 The starting price, i.e. before accounting for the token0 delta\n    /// @param liquidity The amount of usable liquidity\n    /// @param amount How much of token0 to add or remove from virtual reserves\n    /// @param add Whether to add or remove the amount of token0\n    /// @return The price after adding or removing amount, depending on add\n    function getNextSqrtPriceFromAmount0RoundingUp(\n        uint160 sqrtPX96,\n        uint128 liquidity,\n        uint256 amount,\n        bool add\n    ) internal pure returns (uint160) {\n        /// @dev we short circuit amount == 0 because the result is otherwise not guaranteed to equal the input price\n        if (amount == 0) return sqrtPX96;\n        uint256 numerator1 = uint256(liquidity) << FixedPoint96.RESOLUTION;\n\n        if (add) {\n            unchecked {\n                uint256 product;\n                if ((product = amount * sqrtPX96) / amount == sqrtPX96) {\n                    uint256 denominator = numerator1 + product;\n                    if (denominator >= numerator1)\n                        /// @dev always fits in 160 bits\n                        return uint160(FullMath.mulDivRoundingUp(numerator1, sqrtPX96, denominator));\n                }\n            }\n            /// @dev denominator is checked for overflow\n            return uint160(UnsafeMath.divRoundingUp(numerator1, (numerator1 / sqrtPX96) + amount));\n        } else {\n            unchecked {\n                uint256 product;\n                /// @dev if the product overflows, we know the denominator underflows\n                /// @dev in addition, we must check that the denominator does not underflow\n                require((product = amount * sqrtPX96) / amount == sqrtPX96 && numerator1 > product);\n                uint256 denominator = numerator1 - product;\n                return FullMath.mulDivRoundingUp(numerator1, sqrtPX96, denominator).toUint160();\n            }\n        }\n    }\n\n    /// @notice Gets the next sqrt price given a delta of token1\n    /// @dev Always rounds down, because in the exact output case (decreasing price) we need to move the price at least\n    /// far enough to get the desired output amount, and in the exact input case (increasing price) we need to move the\n    /// price less in order to not send too much output.\n    /// The formula we compute is within <1 wei of the lossless version: sqrtPX96 +- amount / liquidity\n    /// @param sqrtPX96 The starting price, i.e., before accounting for the token1 delta\n    /// @param liquidity The amount of usable liquidity\n    /// @param amount How much of token1 to add, or remove, from virtual reserves\n    /// @param add Whether to add, or remove, the amount of token1\n    /// @return The price after adding or removing `amount`\n    function getNextSqrtPriceFromAmount1RoundingDown(\n        uint160 sqrtPX96,\n        uint128 liquidity,\n        uint256 amount,\n        bool add\n    ) internal pure returns (uint160) {\n        /// @dev if we're adding (subtracting), rounding down requires rounding the quotient down (up)\n        /// @dev in both cases, avoid a mulDiv for most inputs\n        if (add) {\n            uint256 quotient = (\n                amount <= type(uint160).max\n                    ? (amount << FixedPoint96.RESOLUTION) / liquidity\n                    : FullMath.mulDiv(amount, FixedPoint96.Q96, liquidity)\n            );\n\n            return (uint256(sqrtPX96) + quotient).toUint160();\n        } else {\n            uint256 quotient = (\n                amount <= type(uint160).max\n                    ? UnsafeMath.divRoundingUp(amount << FixedPoint96.RESOLUTION, liquidity)\n                    : FullMath.mulDivRoundingUp(amount, FixedPoint96.Q96, liquidity)\n            );\n\n            require(sqrtPX96 > quotient);\n            // always fits 160 bits\n            unchecked {\n                return uint160(sqrtPX96 - quotient);\n            }\n        }\n    }\n\n    /// @notice Gets the next sqrt price given an input amount of token0 or token1\n    /// @dev Throws if price or liquidity are 0, or if the next price is out of bounds\n    /// @param sqrtPX96 The starting price, i.e., before accounting for the input amount\n    /// @param liquidity The amount of usable liquidity\n    /// @param amountIn How much of token0, or token1, is being swapped in\n    /// @param zeroForOne Whether the amount in is token0 or token1\n    /// @return sqrtQX96 The price after adding the input amount to token0 or token1\n    function getNextSqrtPriceFromInput(\n        uint160 sqrtPX96,\n        uint128 liquidity,\n        uint256 amountIn,\n        bool zeroForOne\n    ) internal pure returns (uint160 sqrtQX96) {\n        require(sqrtPX96 > 0);\n        require(liquidity > 0);\n\n        // round to make sure that we don't pass the target price\n        return\n            zeroForOne\n                ? getNextSqrtPriceFromAmount0RoundingUp(sqrtPX96, liquidity, amountIn, true)\n                : getNextSqrtPriceFromAmount1RoundingDown(sqrtPX96, liquidity, amountIn, true);\n    }\n\n    /// @notice Gets the next sqrt price given an output amount of token0 or token1\n    /// @dev Throws if price or liquidity are 0 or the next price is out of bounds\n    /// @param sqrtPX96 The starting price before accounting for the output amount\n    /// @param liquidity The amount of usable liquidity\n    /// @param amountOut How much of token0, or token1, is being swapped out\n    /// @param zeroForOne Whether the amount out is token0 or token1\n    /// @return sqrtQX96 The price after removing the output amount of token0 or token1\n    function getNextSqrtPriceFromOutput(\n        uint160 sqrtPX96,\n        uint128 liquidity,\n        uint256 amountOut,\n        bool zeroForOne\n    ) internal pure returns (uint160 sqrtQX96) {\n        require(sqrtPX96 > 0);\n        require(liquidity > 0);\n\n        /// @dev round to make sure that we pass the target price\n        return\n            zeroForOne\n                ? getNextSqrtPriceFromAmount1RoundingDown(sqrtPX96, liquidity, amountOut, false)\n                : getNextSqrtPriceFromAmount0RoundingUp(sqrtPX96, liquidity, amountOut, false);\n    }\n\n    /// @notice Gets the amount0 delta between two prices\n    /// @dev Calculates liquidity / sqrt(lower) - liquidity / sqrt(upper),\n    /// i.e. liquidity * (sqrt(upper) - sqrt(lower)) / (sqrt(upper) * sqrt(lower))\n    /// @param sqrtRatioAX96 A sqrt price\n    /// @param sqrtRatioBX96 Another sqrt price\n    /// @param liquidity The amount of usable liquidity\n    /// @param roundUp Whether to round the amount up or down\n    /// @return amount0 Amount of token0 required to cover a position of size liquidity between the two passed prices\n    function getAmount0Delta(\n        uint160 sqrtRatioAX96,\n        uint160 sqrtRatioBX96,\n        uint128 liquidity,\n        bool roundUp\n    ) internal pure returns (uint256 amount0) {\n        unchecked {\n            if (sqrtRatioAX96 > sqrtRatioBX96) (sqrtRatioAX96, sqrtRatioBX96) = (sqrtRatioBX96, sqrtRatioAX96);\n\n            uint256 numerator1 = uint256(liquidity) << FixedPoint96.RESOLUTION;\n            uint256 numerator2 = sqrtRatioBX96 - sqrtRatioAX96;\n\n            require(sqrtRatioAX96 > 0);\n\n            return\n                roundUp\n                    ? UnsafeMath.divRoundingUp(\n                        FullMath.mulDivRoundingUp(numerator1, numerator2, sqrtRatioBX96),\n                        sqrtRatioAX96\n                    )\n                    : FullMath.mulDiv(numerator1, numerator2, sqrtRatioBX96) / sqrtRatioAX96;\n        }\n    }\n\n    /// @notice Gets the amount1 delta between two prices\n    /// @dev Calculates liquidity * (sqrt(upper) - sqrt(lower))\n    /// @param sqrtRatioAX96 A sqrt price\n    /// @param sqrtRatioBX96 Another sqrt price\n    /// @param liquidity The amount of usable liquidity\n    /// @param roundUp Whether to round the amount up, or down\n    /// @return amount1 Amount of token1 required to cover a position of size liquidity between the two passed prices\n    function getAmount1Delta(\n        uint160 sqrtRatioAX96,\n        uint160 sqrtRatioBX96,\n        uint128 liquidity,\n        bool roundUp\n    ) internal pure returns (uint256 amount1) {\n        unchecked {\n            if (sqrtRatioAX96 > sqrtRatioBX96) (sqrtRatioAX96, sqrtRatioBX96) = (sqrtRatioBX96, sqrtRatioAX96);\n\n            return\n                roundUp\n                    ? FullMath.mulDivRoundingUp(liquidity, sqrtRatioBX96 - sqrtRatioAX96, FixedPoint96.Q96)\n                    : FullMath.mulDiv(liquidity, sqrtRatioBX96 - sqrtRatioAX96, FixedPoint96.Q96);\n        }\n    }\n\n    /// @notice Helper that gets signed token0 delta\n    /// @param sqrtRatioAX96 A sqrt price\n    /// @param sqrtRatioBX96 Another sqrt price\n    /// @param liquidity The change in liquidity for which to compute the amount0 delta\n    /// @return amount0 Amount of token0 corresponding to the passed liquidityDelta between the two prices\n    function getAmount0Delta(\n        uint160 sqrtRatioAX96,\n        uint160 sqrtRatioBX96,\n        int128 liquidity\n    ) internal pure returns (int256 amount0) {\n        unchecked {\n            return\n                liquidity < 0\n                    ? -getAmount0Delta(sqrtRatioAX96, sqrtRatioBX96, uint128(-liquidity), false).toInt256()\n                    : getAmount0Delta(sqrtRatioAX96, sqrtRatioBX96, uint128(liquidity), true).toInt256();\n        }\n    }\n\n    /// @notice Helper that gets signed token1 delta\n    /// @param sqrtRatioAX96 A sqrt price\n    /// @param sqrtRatioBX96 Another sqrt price\n    /// @param liquidity The change in liquidity for which to compute the amount1 delta\n    /// @return amount1 Amount of token1 corresponding to the passed liquidityDelta between the two prices\n    function getAmount1Delta(\n        uint160 sqrtRatioAX96,\n        uint160 sqrtRatioBX96,\n        int128 liquidity\n    ) internal pure returns (int256 amount1) {\n        unchecked {\n            return\n                liquidity < 0\n                    ? -getAmount1Delta(sqrtRatioAX96, sqrtRatioBX96, uint128(-liquidity), false).toInt256()\n                    : getAmount1Delta(sqrtRatioAX96, sqrtRatioBX96, uint128(liquidity), true).toInt256();\n        }\n    }\n}\n"
        },
        "contracts/CL/core/libraries/SwapMath.sol": {
            "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity ^0.8.0;\n\nimport {FullMath} from './FullMath.sol';\nimport {SqrtPriceMath} from './SqrtPriceMath.sol';\n\n/// @title Computes the result of a swap within ticks\n/// @notice Contains methods for computing the result of a swap within a single tick price range, i.e., a single tick.\nlibrary SwapMath {\n    /// @notice Computes the result of swapping some amount in, or amount out, given the parameters of the swap\n    /// @dev The fee, plus the amount in, will never exceed the amount remaining if the swap's `amountSpecified` is positive\n    /// @param sqrtRatioCurrentX96 The current sqrt price of the pool\n    /// @param sqrtRatioTargetX96 The price that cannot be exceeded, from which the direction of the swap is inferred\n    /// @param liquidity The usable liquidity\n    /// @param amountRemaining How much input or output amount is remaining to be swapped in/out\n    /// @param feePips The fee taken from the input amount, expressed in hundredths of a bip\n    /// @return sqrtRatioNextX96 The price after swapping the amount in/out, not to exceed the price target\n    /// @return amountIn The amount to be swapped in, of either token0 or token1, based on the direction of the swap\n    /// @return amountOut The amount to be received, of either token0 or token1, based on the direction of the swap\n    /// @return feeAmount The amount of input that will be taken as a fee\n    function computeSwapStep(\n        uint160 sqrtRatioCurrentX96,\n        uint160 sqrtRatioTargetX96,\n        uint128 liquidity,\n        int256 amountRemaining,\n        uint24 feePips\n    ) internal pure returns (uint160 sqrtRatioNextX96, uint256 amountIn, uint256 amountOut, uint256 feeAmount) {\n        unchecked {\n            bool zeroForOne = sqrtRatioCurrentX96 >= sqrtRatioTargetX96;\n            bool exactIn = amountRemaining >= 0;\n\n            if (exactIn) {\n                uint256 amountRemainingLessFee = FullMath.mulDiv(uint256(amountRemaining), 1e6 - feePips, 1e6);\n                amountIn = zeroForOne\n                    ? SqrtPriceMath.getAmount0Delta(sqrtRatioTargetX96, sqrtRatioCurrentX96, liquidity, true)\n                    : SqrtPriceMath.getAmount1Delta(sqrtRatioCurrentX96, sqrtRatioTargetX96, liquidity, true);\n                if (amountRemainingLessFee >= amountIn) sqrtRatioNextX96 = sqrtRatioTargetX96;\n                else\n                    sqrtRatioNextX96 = SqrtPriceMath.getNextSqrtPriceFromInput(\n                        sqrtRatioCurrentX96,\n                        liquidity,\n                        amountRemainingLessFee,\n                        zeroForOne\n                    );\n            } else {\n                amountOut = zeroForOne\n                    ? SqrtPriceMath.getAmount1Delta(sqrtRatioTargetX96, sqrtRatioCurrentX96, liquidity, false)\n                    : SqrtPriceMath.getAmount0Delta(sqrtRatioCurrentX96, sqrtRatioTargetX96, liquidity, false);\n                if (uint256(-amountRemaining) >= amountOut) sqrtRatioNextX96 = sqrtRatioTargetX96;\n                else\n                    sqrtRatioNextX96 = SqrtPriceMath.getNextSqrtPriceFromOutput(\n                        sqrtRatioCurrentX96,\n                        liquidity,\n                        uint256(-amountRemaining),\n                        zeroForOne\n                    );\n            }\n\n            bool max = sqrtRatioTargetX96 == sqrtRatioNextX96;\n\n            /// @dev get the input/output amounts\n            if (zeroForOne) {\n                amountIn = max && exactIn\n                    ? amountIn\n                    : SqrtPriceMath.getAmount0Delta(sqrtRatioNextX96, sqrtRatioCurrentX96, liquidity, true);\n                amountOut = max && !exactIn\n                    ? amountOut\n                    : SqrtPriceMath.getAmount1Delta(sqrtRatioNextX96, sqrtRatioCurrentX96, liquidity, false);\n            } else {\n                amountIn = max && exactIn\n                    ? amountIn\n                    : SqrtPriceMath.getAmount1Delta(sqrtRatioCurrentX96, sqrtRatioNextX96, liquidity, true);\n                amountOut = max && !exactIn\n                    ? amountOut\n                    : SqrtPriceMath.getAmount0Delta(sqrtRatioCurrentX96, sqrtRatioNextX96, liquidity, false);\n            }\n\n            /// @dev cap the output amount to not exceed the remaining output amount\n            if (!exactIn && amountOut > uint256(-amountRemaining)) {\n                amountOut = uint256(-amountRemaining);\n            }\n\n            if (exactIn && sqrtRatioNextX96 != sqrtRatioTargetX96) {\n                /// @dev we didn't reach the target, so take the remainder of the maximum input as fee\n                feeAmount = uint256(amountRemaining) - amountIn;\n            } else {\n                feeAmount = FullMath.mulDivRoundingUp(amountIn, feePips, 1e6 - feePips);\n            }\n        }\n    }\n}\n"
        },
        "contracts/CL/core/interfaces/IRamsesV3PoolDeployer.sol": {
            "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0;\n\n/// @title An interface for a contract that is capable of deploying Ramses V3 Pools\n/// @notice A contract that constructs a pool must implement this to pass arguments to the pool\n/// @dev This is used to avoid having constructor arguments in the pool contract, which results in the init code hash\n/// of the pool being constant allowing the CREATE2 address of the pool to be cheaply computed on-chain\ninterface IRamsesV3PoolDeployer {\n    /// @notice Get the parameters to be used in constructing the pool, set transiently during pool creation.\n    /// @dev Called by the pool constructor to fetch the parameters of the pool\n    /// Returns factory The factory address\n    /// Returns token0 The first token of the pool by address sort order\n    /// Returns token1 The second token of the pool by address sort order\n    /// Returns fee The fee collected upon every swap in the pool, denominated in hundredths of a bip\n    /// Returns tickSpacing The minimum number of ticks between initialized ticks\n    function parameters()\n        external\n        view\n        returns (address factory, address token0, address token1, uint24 fee, int24 tickSpacing);\n\n    /// @dev Deploys a pool with the given parameters by transiently setting the parameters storage slot and then\n    /// clearing it after deploying the pool.\n    /// @param token0 The first token of the pool by address sort order\n    /// @param token1 The second token of the pool by address sort order\n    /// @param tickSpacing The tickSpacing of the pool\n    function deploy(address token0, address token1, int24 tickSpacing) external returns (address pool);\n\n    function RamsesV3Factory() external view returns (address factory);\n}\n"
        },
        "contracts/CL/core/interfaces/IRamsesV3Factory.sol": {
            "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0;\n\n/// @title The interface for the Ramses V3 Factory\n/// @notice The Ramses V3 Factory facilitates creation of Ramses V3 pools and control over the protocol fees\ninterface IRamsesV3Factory {\n    /// @notice Emitted when a pool is created\n    /// @param token0 The first token of the pool by address sort order\n    /// @param token1 The second token of the pool by address sort order\n    /// @param fee The fee collected upon every swap in the pool, denominated in hundredths of a bip\n    /// @param tickSpacing The minimum number of ticks between initialized ticks\n    /// @param pool The address of the created pool\n    event PoolCreated(\n        address indexed token0, address indexed token1, uint24 indexed fee, int24 tickSpacing, address pool\n    );\n\n    /// @notice Emitted when a new tickspacing amount is enabled for pool creation via the factory\n    /// @dev unlike UniswapV3, we map via the tickSpacing rather than the fee tier\n    /// @param tickSpacing The minimum number of ticks between initialized ticks\n    /// @param fee The fee, denominated in hundredths of a bip\n    event TickSpacingEnabled(int24 indexed tickSpacing, uint24 indexed fee);\n\n    /// @notice Emitted when the protocol fee is changed\n    /// @param feeProtocolOld The previous value of the protocol fee\n    /// @param feeProtocolNew The updated value of the protocol fee\n    event SetFeeProtocol(uint24 feeProtocolOld, uint24 feeProtocolNew);\n\n    /// @notice Emitted when the protocol fee is changed\n    /// @param pool The pool address\n    /// @param feeProtocolOld The previous value of the protocol fee\n    /// @param feeProtocolNew The updated value of the protocol fee\n    event SetPoolFeeProtocol(address pool, uint24 feeProtocolOld, uint24 feeProtocolNew);\n\n    /// @notice Emitted when a pool's fee is changed\n    /// @param pool The pool address\n    /// @param newFee The updated value of the protocol fee\n    event FeeAdjustment(address pool, uint24 newFee);\n\n    /// @notice Emitted when the fee collector is changed\n    /// @param oldFeeCollector The previous implementation\n    /// @param newFeeCollector The new implementation\n    event FeeCollectorChanged(address indexed oldFeeCollector, address indexed newFeeCollector);\n\n    /// @notice Returns the PoolDeployer address\n    /// @return The address of the PoolDeployer contract\n    function ramsesV3PoolDeployer() external returns (address);\n\n    /// @notice Returns the fee amount for a given tickSpacing, if enabled, or 0 if not enabled\n    /// @dev A tickSpacing can never be removed, so this value should be hard coded or cached in the calling context\n    /// @dev unlike UniswapV3, we map via the tickSpacing rather than the fee tier\n    /// @param tickSpacing The enabled tickSpacing. Returns 0 in case of unenabled tickSpacing\n    /// @return initialFee The initial fee\n    function tickSpacingInitialFee(int24 tickSpacing) external view returns (uint24 initialFee);\n\n    /// @notice Returns the pool address for a given pair of tokens and a tickSpacing, or address 0 if it does not exist\n    /// @dev tokenA and tokenB may be passed in either token0/token1 or token1/token0 order\n    /// @dev unlike UniswapV3, we map via the tickSpacing rather than the fee tier\n    /// @param tokenA The contract address of either token0 or token1\n    /// @param tokenB The contract address of the other token\n    /// @param tickSpacing The tickSpacing of the pool\n    /// @return pool The pool address\n    function getPool(address tokenA, address tokenB, int24 tickSpacing) external view returns (address pool);\n\n    /// @notice Creates a pool for the given two tokens and fee\n    /// @dev unlike UniswapV3, we map via the tickSpacing rather than the fee tier\n    /// @param tokenA One of the two tokens in the desired pool\n    /// @param tokenB The other of the two tokens in the desired pool\n    /// @param tickSpacing The desired tickSpacing for the pool\n    /// @param sqrtPriceX96 initial sqrtPriceX96 of the pool\n    /// @dev tokenA and tokenB may be passed in either order: token0/token1 or token1/token0.\n    /// @dev The call will revert if the pool already exists, the tickSpacing is invalid, or the token arguments are invalid.\n    /// @return pool The address of the newly created pool\n    function createPool(address tokenA, address tokenB, int24 tickSpacing, uint160 sqrtPriceX96)\n        external\n        returns (address pool);\n\n    /// @notice Enables a tickSpacing with the given initialFee amount\n    /// @dev unlike UniswapV3, we map via the tickSpacing rather than the fee tier\n    /// @dev tickSpacings may never be removed once enabled\n    /// @param tickSpacing The spacing between ticks to be enforced for all pools created\n    /// @param initialFee The initial fee amount, denominated in hundredths of a bip (i.e. 1e-6)\n    function enableTickSpacing(int24 tickSpacing, uint24 initialFee) external;\n\n    /// @notice Returns the default protocol fee value\n    /// @return _feeProtocol The default protocol fee percentage\n    function feeProtocol() external view returns (uint24 _feeProtocol);\n\n    /// @notice Returns the protocol fee percentage for a specific pool\n    /// @dev If the fee is 0 or the pool is uninitialized, returns the Factory's default feeProtocol\n    /// @param pool The address of the pool\n    /// @return _feeProtocol The protocol fee percentage for the specified pool\n    function poolFeeProtocol(address pool) external view returns (uint24 _feeProtocol);\n\n    /// @notice Sets the default protocol fee percentage\n    /// @param _feeProtocol New default protocol fee percentage for token0 and token1\n    function setFeeProtocol(uint24 _feeProtocol) external;\n\n    /// @notice Retrieves the parameters used in constructing a pool\n    /// @dev Called by the pool constructor to fetch the pool's parameters\n    /// @return factory The factory address\n    /// @return token0 The first token of the pool by address sort order\n    /// @return token1 The second token of the pool by address sort order\n    /// @return fee The initialized fee tier of the pool, denominated in hundredths of a bip\n    /// @return tickSpacing The minimum number of ticks between initialized ticks\n    function parameters()\n        external\n        view\n        returns (address factory, address token0, address token1, uint24 fee, int24 tickSpacing);\n\n    /// @notice Updates the fee collector address\n    /// @param _feeCollector The new fee collector address\n    function setFeeCollector(address _feeCollector) external;\n\n    /// @notice Updates the swap fee for a specific pool\n    /// @param _pool The address of the pool to modify\n    /// @param _fee The new fee value, scaled where 1_000_000 = 100%\n    function setFee(address _pool, uint24 _fee) external;\n\n    /// @notice Returns the current fee collector address\n    /// @dev The fee collector contract determines the distribution of protocol fees\n    /// @return The address of the fee collector contract\n    function feeCollector() external view returns (address);\n\n    /// @notice Flag for getting a pool to use the default feeProcotol\n    /// @dev type(uint24).max denotes using default feeProcotol\n    function DEFAULT_FEE_FLAG() external view returns (uint24);\n\n    /// @notice Updates the protocol fee percentage for a specific pool\n    /// @dev type(uint24).max denotes using default feeProcotol\n    /// @param pool The address of the pool to modify\n    /// @param _feeProtocol The new protocol fee percentage to assign\n    function setPoolFeeProtocol(address pool, uint24 _feeProtocol) external;\n\n    /// @notice Enables fee protocol splitting upon gauge creation\n    /// @param pool The address of the pool to enable fee splitting for\n    function gaugeFeeSplitEnable(address pool) external;\n\n    /// @notice Updates the voter contract address\n    /// @param _voter The new voter contract address\n    function setVoter(address _voter) external;\n\n    /// @notice Checks if a given address is a V3 pool\n    /// @param _pool The address to check\n    /// @return isV3 True if the address is a V3 pool, false otherwise\n    function isPairV3(address _pool) external view returns (bool isV3);\n\n    /// @notice Initializes the factory with a pool deployer\n    /// @param poolDeployer The address of the pool deployer contract\n    function initialize(address poolDeployer) external;\n\n    /// @notice returns the voter\n    function voter() external returns (address);\n}\n"
        },
        "contracts/CL/core/interfaces/IERC20Minimal.sol": {
            "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0;\n\n/// @title Minimal ERC20 interface for Ramses\n/// @notice Contains a subset of the full ERC20 interface that is used in Ramses V3\ninterface IERC20Minimal {\n    /// @notice Returns the balance of a token\n    /// @param account The account for which to look up the number of tokens it has, i.e. its balance\n    /// @return The number of tokens held by the account\n    function balanceOf(address account) external view returns (uint256);\n\n    /// @notice Transfers the amount of token from the `msg.sender` to the recipient\n    /// @param recipient The account that will receive the amount transferred\n    /// @param amount The number of tokens to send from the sender to the recipient\n    /// @return Returns true for a successful transfer, false for an unsuccessful transfer\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /// @notice Returns the current allowance given to a spender by an owner\n    /// @param owner The account of the token owner\n    /// @param spender The account of the token spender\n    /// @return The current allowance granted by `owner` to `spender`\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /// @notice Sets the allowance of a spender from the `msg.sender` to the value `amount`\n    /// @param spender The account which will be allowed to spend a given amount of the owners tokens\n    /// @param amount The amount of tokens allowed to be used by `spender`\n    /// @return Returns true for a successful approval, false for unsuccessful\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /// @notice Transfers `amount` tokens from `sender` to `recipient` up to the allowance given to the `msg.sender`\n    /// @param sender The account from which the transfer will be initiated\n    /// @param recipient The recipient of the transfer\n    /// @param amount The amount of the transfer\n    /// @return Returns true for a successful transfer, false for unsuccessful\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    /// @notice Event emitted when tokens are transferred from one address to another, either via `#transfer` or `#transferFrom`.\n    /// @param from The account from which the tokens were sent, i.e. the balance decreased\n    /// @param to The account to which the tokens were sent, i.e. the balance increased\n    /// @param value The amount of tokens that were transferred\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /// @notice Event emitted when the approval amount for the spender of a given owner's tokens changes.\n    /// @param owner The account that approved spending of its tokens\n    /// @param spender The account for which the spending allowance was modified\n    /// @param value The new allowance from the owner to the spender\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
        },
        "contracts/CL/core/interfaces/callback/IUniswapV3MintCallback.sol": {
            "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0;\n\n/// @dev original UniswapV3 callbacks maintained to ensure seamless integrations\n\n/// @title Callback for IUniswapV3PoolActions#mint\n/// @notice Any contract that calls IUniswapV3PoolActions#mint must implement this interface\ninterface IUniswapV3MintCallback {\n    /// @notice Called to `msg.sender` after minting liquidity to a position from IUniswapV3Pool#mint.\n    /// @dev In the implementation you must pay the pool tokens owed for the minted liquidity.\n    /// The caller of this method must be checked to be a UniswapV3Pool deployed by the canonical UniswapV3Factory.\n    /// @param amount0Owed The amount of token0 due to the pool for the minted liquidity\n    /// @param amount1Owed The amount of token1 due to the pool for the minted liquidity\n    /// @param data Any data passed through by the caller via the IUniswapV3PoolActions#mint call\n    function uniswapV3MintCallback(uint256 amount0Owed, uint256 amount1Owed, bytes calldata data) external;\n}\n"
        },
        "contracts/CL/core/interfaces/callback/IUniswapV3SwapCallback.sol": {
            "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0;\n\n/// @dev original UniswapV3 callbacks maintained to ensure seamless integrations\n\n/// @title Callback for IUniswapV3PoolActions#swap\n/// @notice Any contract that calls IUniswapV3PoolActions#swap must implement this interface\ninterface IUniswapV3SwapCallback {\n    /// @notice Called to `msg.sender` after executing a swap via IUniswapV3Pool#swap.\n    /// @dev In the implementation you must pay the pool tokens owed for the swap.\n    /// The caller of this method must be checked to be a UniswapV3Pool deployed by the canonical UniswapV3Factory.\n    /// amount0Delta and amount1Delta can both be 0 if no tokens were swapped.\n    /// @param amount0Delta The amount of token0 that was sent (negative) or must be received (positive) by the pool by\n    /// the end of the swap. If positive, the callback must send that amount of token0 to the pool.\n    /// @param amount1Delta The amount of token1 that was sent (negative) or must be received (positive) by the pool by\n    /// the end of the swap. If positive, the callback must send that amount of token1 to the pool.\n    /// @param data Any data passed through by the caller via the IUniswapV3PoolActions#swap call\n    function uniswapV3SwapCallback(int256 amount0Delta, int256 amount1Delta, bytes calldata data) external;\n}\n"
        },
        "contracts/CL/core/interfaces/callback/IUniswapV3FlashCallback.sol": {
            "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0;\n\n/// @dev original UniswapV3 callbacks maintained to ensure seamless integrations\n\n/// @title Callback for IUniswapV3PoolActions#flash\n/// @notice Any contract that calls IUniswapV3PoolActions#flash must implement this interface\ninterface IUniswapV3FlashCallback {\n    /// @notice Called to `msg.sender` after transferring to the recipient from IUniswapV3Pool#flash.\n    /// @dev In the implementation you must repay the pool the tokens sent by flash plus the computed fee amounts.\n    /// The caller of this method must be checked to be a UniswapV3Pool deployed by the canonical UniswapV3Factory.\n    /// @param fee0 The fee amount in token0 due to the pool by the end of the flash\n    /// @param fee1 The fee amount in token1 due to the pool by the end of the flash\n    /// @param data Any data passed through by the caller via the IUniswapV3PoolActions#flash call\n    function uniswapV3FlashCallback(uint256 fee0, uint256 fee1, bytes calldata data) external;\n}\n"
        },
        "contracts/CL/core/libraries/ProtocolActions.sol": {
            "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity ^0.8.0;\npragma abicoder v2;\n\nimport {PoolStorage} from \"./PoolStorage.sol\";\nimport {TransferHelper} from \"./TransferHelper.sol\";\nimport {IRamsesV3Factory} from \"../interfaces/IRamsesV3Factory.sol\";\n\nlibrary ProtocolActions {\n    uint256 internal constant FEE_DENOM = 1_000_000;\n\n    error NOT_AUTHORIZED();\n    error INVALID_FEE();\n\n    /// @notice Emitted when the protocol fee is changed by the pool\n    /// @param feeProtocolOld The previous value of the token0 protocol fee\n    /// @param feeProtocolNew The updated value of the token1 protocol fee\n    event SetFeeProtocol(uint24 feeProtocolOld, uint24 feeProtocolNew);\n\n    /// @notice Emitted when the collected protocol fees are withdrawn by the fee collector\n    /// @param sender The address that collects the protocol fees\n    /// @param recipient The address that receives the collected protocol fees\n    /// @param amount0 The amount of token0 protocol fees that is withdrawn\n    /// @param amount0 The amount of token1 protocol fees that is withdrawn\n    event CollectProtocol(address indexed sender, address indexed recipient, uint128 amount0, uint128 amount1);\n\n    event FeeAdjustment(uint24 oldFee, uint24 newFee);\n\n    /// @notice Set % share of the fees that do not go to liquidity providers\n    /// @dev Fetches from factory directly\n    function setFeeProtocol(address factory) external {\n        PoolStorage.PoolState storage $ = PoolStorage.getStorage();\n        /// @dev fetch \"old\" feeProtocol from storage slot0\n        uint24 feeProtocolOld = $.slot0.feeProtocol;\n        /// @dev fetch \"new\" feeProtocol from factory mapping\n        uint24 feeProtocol = IRamsesV3Factory(factory).poolFeeProtocol(address(this));\n        /// @dev if the two values are not the same, the factory mapping takes precedent\n        if (feeProtocol != feeProtocolOld) {\n            /// @dev set the storage feeProtocol to the factory's\n            $.slot0.feeProtocol = feeProtocol;\n            emit SetFeeProtocol(feeProtocolOld, feeProtocol);\n        }\n    }\n\n    /// @notice Collect the protocol fee accrued to the pool\n    /// @param recipient The address to which collected protocol fees should be sent\n    /// @param amount0Requested The maximum amount of token0 to send, can be 0 to collect fees in only token1\n    /// @param amount1Requested The maximum amount of token1 to send, can be 0 to collect fees in only token0\n    /// @return amount0 The protocol fee collected in token0\n    /// @return amount1 The protocol fee collected in token1\n    function collectProtocol(\n        address recipient,\n        uint128 amount0Requested,\n        uint128 amount1Requested,\n        address token0,\n        address token1\n    ) external returns (uint128 amount0, uint128 amount1) {\n        PoolStorage.PoolState storage $ = PoolStorage.getStorage();\n\n        amount0 = amount0Requested > $.protocolFees.token0 ? $.protocolFees.token0 : amount0Requested;\n        amount1 = amount1Requested > $.protocolFees.token1 ? $.protocolFees.token1 : amount1Requested;\n\n        unchecked {\n            if (amount0 > 0) {\n                if (amount0 == $.protocolFees.token0) amount0--;\n                /// @dev ensure that the slot is not cleared, for gas savings\n                $.protocolFees.token0 -= amount0;\n                TransferHelper.safeTransfer(token0, recipient, amount0);\n            }\n            if (amount1 > 0) {\n                if (amount1 == $.protocolFees.token1) amount1--;\n                /// @dev ensure that the slot is not cleared, for gas savings\n                $.protocolFees.token1 -= amount1;\n                TransferHelper.safeTransfer(token1, recipient, amount1);\n            }\n        }\n        emit CollectProtocol(msg.sender, recipient, amount0, amount1);\n    }\n\n    function setFee(uint24 _fee, address factory) external {\n        PoolStorage.PoolState storage $ = PoolStorage.getStorage();\n        if (msg.sender != factory) revert NOT_AUTHORIZED();\n        if (_fee > FEE_DENOM) revert INVALID_FEE();\n        uint24 _oldFee = $.fee;\n        $.fee = _fee;\n        emit FeeAdjustment(_oldFee, _fee);\n    }\n}\n"
        },
        "contracts/CL/core/libraries/PoolStorage.sol": {
            "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity ^0.8.0;\n\nstruct Slot0 {\n    /// @dev the current price\n    uint160 sqrtPriceX96;\n    /// @dev the current tick\n    int24 tick;\n    /// @dev the most-recently updated index of the observations array\n    uint16 observationIndex;\n    /// @dev the current maximum number of observations that are being stored\n    uint16 observationCardinality;\n    /// @dev the next maximum number of observations to store, triggered in observations.write\n    uint16 observationCardinalityNext;\n    /// @dev the current protocol fee as a percentage of the swap fee taken on withdrawal\n    /// @dev represented as an integer denominator (1/x)%\n    uint24 feeProtocol;\n    /// @dev whether the pool is locked\n    bool unlocked;\n}\n\nstruct Observation {\n    /// @dev the block timestamp of the observation\n    uint32 blockTimestamp;\n    /// @dev the tick accumulator, i.e. tick * time elapsed since the pool was first initialized\n    int56 tickCumulative;\n    /// @dev the seconds per liquidity, i.e. seconds elapsed / max(1, liquidity) since the pool was first initialized\n    uint160 secondsPerLiquidityCumulativeX128;\n    /// @dev whether or not the observation is initialized\n    bool initialized;\n}\n\nstruct RewardInfo {\n    /// @dev used to account for changes in the deposit amount\n    int256 secondsDebtX96;\n    /// @dev used to check if starting seconds have already been written\n    bool initialized;\n    /// @dev used to account for changes in secondsPerLiquidity\n    int160 secondsPerLiquidityPeriodStartX128;\n}\n\n/// @dev info stored for each user's position\nstruct PositionInfo {\n    /// @dev the amount of liquidity owned by this position\n    uint128 liquidity;\n    /// @dev fee growth per unit of liquidity as of the last update to liquidity or fees owed\n    uint256 feeGrowthInside0LastX128;\n    uint256 feeGrowthInside1LastX128;\n    /// @dev the fees owed to the position owner in token0/token1\n    uint128 tokensOwed0;\n    uint128 tokensOwed1;\n    mapping(uint256 => RewardInfo) periodRewardInfo;\n}\n\n/// @dev info stored for each initialized individual tick\nstruct TickInfo {\n    /// @dev the total position liquidity that references this tick\n    uint128 liquidityGross;\n    /// @dev amount of net liquidity added (subtracted) when tick is crossed from left to right (right to left),\n    int128 liquidityNet;\n    /// @dev fee growth per unit of liquidity on the _other_ side of this tick (relative to the current tick)\n    /// @dev only has relative meaning, not absolute  the value depends on when the tick is initialized\n    uint256 feeGrowthOutside0X128;\n    uint256 feeGrowthOutside1X128;\n    /// @dev the cumulative tick value on the other side of the tick\n    int56 tickCumulativeOutside;\n    /// @dev the seconds per unit of liquidity on the _other_ side of this tick (relative to the current tick)\n    /// @dev only has relative meaning, not absolute  the value depends on when the tick is initialized\n    uint160 secondsPerLiquidityOutsideX128;\n    /// @dev the seconds spent on the other side of the tick (relative to the current tick)\n    /// @dev only has relative meaning, not absolute  the value depends on when the tick is initialized\n    uint32 secondsOutside;\n    /// @dev true iff the tick is initialized, i.e. the value is exactly equivalent to the expression liquidityGross != 0\n    /// @dev these 8 bits are set to prevent fresh sstores when crossing newly initialized ticks\n    bool initialized;\n    /// @dev secondsPerLiquidityOutsideX128 separated into periods, placed here to preserve struct slots\n    mapping(uint256 => uint256) periodSecondsPerLiquidityOutsideX128;\n}\n\n/// @dev info stored for each period\nstruct PeriodInfo {\n    uint32 previousPeriod;\n    int24 startTick;\n    int24 lastTick;\n    uint160 endSecondsPerLiquidityPeriodX128;\n}\n\n/// @dev accumulated protocol fees in token0/token1 units\nstruct ProtocolFees {\n    uint128 token0;\n    uint128 token1;\n}\n\n/// @dev Position period and liquidity\nstruct PositionCheckpoint {\n    uint256 period;\n    uint256 liquidity;\n}\n\n/// @dev Needed for Gauge reward validations\nstruct RewarderCheckpoint {\n    uint32 timestamp;\n    int128 liquidityDelta;\n}\n\nlibrary PoolStorage {\n    /// @dev keccak256(abi.encode(uint256(keccak256(\"pool.storage\")) - 1)) & ~bytes32(uint256(0xff));\n    bytes32 public constant POOL_STORAGE_LOCATION = 0xf047b0c59244a0faf8e48cb6b6fde518e6717176152b6dd953628cd9dccb2800;\n\n    /// @customstoragelocation erc7201pool.storage\n    struct PoolState {\n        Slot0 slot0;\n        uint24 fee;\n        uint256 feeGrowthGlobal0X128;\n        uint256 feeGrowthGlobal1X128;\n        uint256 grossFeeGrowthGlobal0X128;\n        uint256 grossFeeGrowthGlobal1X128;\n        ProtocolFees protocolFees;\n        uint128 liquidity;\n        mapping(int24 => TickInfo) _ticks;\n        mapping(int16 => uint256) tickBitmap;\n        mapping(bytes32 => PositionInfo) positions;\n        Observation[65535] observations;\n        mapping(uint256 => PeriodInfo) periods;\n        uint256 lastPeriod;\n        mapping(bytes32 => PositionCheckpoint[]) positionCheckpoints;\n        bool initialized;\n        address nfpManager;\n        mapping(bytes32 => RewarderCheckpoint) positionLastRewarderCheckpoint;\n    }\n\n    /// @dev Return state storage struct for reading and writing\n    function getStorage() internal pure returns (PoolState storage $) {\n        assembly {\n            $.slot := POOL_STORAGE_LOCATION\n        }\n    }\n}\n"
        },
        "dependencies/@openzeppelin-contracts-5.1.0/interfaces/IERC20.sol": {
            "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (interfaces/IERC20.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC20} from \"../token/ERC20/IERC20.sol\";\n"
        },
        "contracts/CL/core/interfaces/pool/IRamsesV3PoolImmutables.sol": {
            "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0;\n\n/// @title Pool state that never changes\n/// @notice These parameters are fixed for a pool forever, i.e., the methods will always return the same values\ninterface IRamsesV3PoolImmutables {\n    /// @notice The contract that deployed the pool, which must adhere to the IRamsesV3Factory interface\n    /// @return The contract address\n    function factory() external view returns (address);\n\n    /// @notice The first of the two tokens of the pool, sorted by address\n    /// @return The token contract address\n    function token0() external view returns (address);\n\n    /// @notice The second of the two tokens of the pool, sorted by address\n    /// @return The token contract address\n    function token1() external view returns (address);\n\n    /// @notice The pool's fee in hundredths of a bip, i.e. 1e-6\n    /// @return The fee\n    function fee() external view returns (uint24);\n\n    /// @notice The pool tick spacing\n    /// @dev Ticks can only be used at multiples of this value, minimum of 1 and always positive\n    /// e.g.: a tickSpacing of 3 means ticks can be initialized every 3rd tick, i.e., ..., -6, -3, 0, 3, 6, ...\n    /// This value is an int24 to avoid casting even though it is always positive.\n    /// @return The tick spacing\n    function tickSpacing() external view returns (int24);\n\n    /// @notice The maximum amount of position liquidity that can use any tick in the range\n    /// @dev This parameter is enforced per tick to prevent liquidity from overflowing a uint128 at any point, and\n    /// also prevents out-of-range liquidity from being used to prevent adding in-range liquidity to a pool\n    /// @return The max amount of liquidity per tick\n    function maxLiquidityPerTick() external view returns (uint128);\n}\n"
        },
        "contracts/CL/core/interfaces/pool/IRamsesV3PoolState.sol": {
            "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0;\n\n/// @title Pool state that can change\n/// @notice These methods compose the pool's state, and can change with any frequency including multiple times\n/// per transaction\ninterface IRamsesV3PoolState {\n    /// @notice The 0th storage slot in the pool stores many values, and is exposed as a single method to save gas\n    /// when accessed externally.\n    /// @return sqrtPriceX96 The current price of the pool as a sqrt(token1/token0) Q64.96 value\n    /// @return tick The current tick of the pool, i.e. according to the last tick transition that was run.\n    /// This value may not always be equal to SqrtTickMath.getTickAtSqrtRatio(sqrtPriceX96) if the price is on a tick\n    /// boundary.\n    /// @return observationIndex The index of the last oracle observation that was written,\n    /// @return observationCardinality The current maximum number of observations stored in the pool,\n    /// @return observationCardinalityNext The next maximum number of observations, to be updated when the observation.\n    /// @return feeProtocol The protocol fee for both tokens of the pool.\n    /// Encoded as two 4 bit values, where the protocol fee of token1 is shifted 4 bits and the protocol fee of token0\n    /// is the lower 4 bits. Used as the denominator of a fraction of the swap fee, e.g. 4 means 1/4th of the swap fee.\n    /// unlocked Whether the pool is currently locked to reentrancy\n    function slot0()\n        external\n        view\n        returns (\n            uint160 sqrtPriceX96,\n            int24 tick,\n            uint16 observationIndex,\n            uint16 observationCardinality,\n            uint16 observationCardinalityNext,\n            uint24 feeProtocol,\n            bool unlocked\n        );\n\n    /// @notice The fee growth as a Q128.128 fees of token0 collected per unit of liquidity for the entire life of the pool\n    /// @dev This value can overflow the uint256\n    function feeGrowthGlobal0X128() external view returns (uint256);\n\n    /// @notice The fee growth as a Q128.128 fees of token1 collected per unit of liquidity for the entire life of the pool\n    /// @dev This value can overflow the uint256\n    function feeGrowthGlobal1X128() external view returns (uint256);\n\n    /// @notice Get the accumulated fee growth for the first token in the pool before protocol fees\n    /// @dev This value can overflow the uint256\n    function grossFeeGrowthGlobal0X128() external view returns (uint256);\n\n    /// @notice Get the accumulated fee growth for the second token in the pool before protocol fees\n    /// @dev This value can overflow the uint256\n    function grossFeeGrowthGlobal1X128() external view returns (uint256);\n\n    /// @notice The amounts of token0 and token1 that are owed to the protocol\n    /// @dev Protocol fees will never exceed uint128 max in either token\n    function protocolFees() external view returns (uint128 token0, uint128 token1);\n\n    /// @notice The currently in range liquidity available to the pool\n    /// @dev This value has no relationship to the total liquidity across all ticks\n    /// @return The liquidity at the current price of the pool\n    function liquidity() external view returns (uint128);\n\n    /// @notice Look up information about a specific tick in the pool\n    /// @param tick The tick to look up\n    /// @return liquidityGross the total amount of position liquidity that uses the pool either as tick lower or\n    /// tick upper\n    /// @return liquidityNet how much liquidity changes when the pool price crosses the tick,\n    /// @return feeGrowthOutside0X128 the fee growth on the other side of the tick from the current tick in token0,\n    /// @return feeGrowthOutside1X128 the fee growth on the other side of the tick from the current tick in token1,\n    /// @return tickCumulativeOutside the cumulative tick value on the other side of the tick from the current tick\n    /// @return secondsPerLiquidityOutsideX128 the seconds spent per liquidity on the other side of the tick from the current tick,\n    /// @return secondsOutside the seconds spent on the other side of the tick from the current tick,\n    /// @return initialized Set to true if the tick is initialized, i.e. liquidityGross is greater than 0, otherwise equal to false.\n    /// Outside values can only be used if the tick is initialized, i.e. if liquidityGross is greater than 0.\n    /// In addition, these values are only relative and must be used only in comparison to previous snapshots for\n    /// a specific position.\n    function ticks(\n        int24 tick\n    )\n        external\n        view\n        returns (\n            uint128 liquidityGross,\n            int128 liquidityNet,\n            uint256 feeGrowthOutside0X128,\n            uint256 feeGrowthOutside1X128,\n            int56 tickCumulativeOutside,\n            uint160 secondsPerLiquidityOutsideX128,\n            uint32 secondsOutside,\n            bool initialized\n        );\n\n    /// @notice Returns 256 packed tick initialized boolean values. See TickBitmap for more information\n    function tickBitmap(int16 wordPosition) external view returns (uint256);\n\n    /// @notice Returns the information about a position by the position's key\n    /// @param key The position's key is a hash of a preimage composed by the owner, tickLower and tickUpper\n    /// @return liquidity The amount of liquidity in the position,\n    /// @return feeGrowthInside0LastX128 fee growth of token0 inside the tick range as of the last mint/burn/poke,\n    /// @return feeGrowthInside1LastX128 fee growth of token1 inside the tick range as of the last mint/burn/poke,\n    /// @return tokensOwed0 the computed amount of token0 owed to the position as of the last mint/burn/poke,\n    /// @return tokensOwed1 the computed amount of token1 owed to the position as of the last mint/burn/poke\n    function positions(\n        bytes32 key\n    )\n        external\n        view\n        returns (\n            uint128 liquidity,\n            uint256 feeGrowthInside0LastX128,\n            uint256 feeGrowthInside1LastX128,\n            uint128 tokensOwed0,\n            uint128 tokensOwed1\n        );\n\n    /// @notice Returns data about a specific observation index\n    /// @param index The element of the observations array to fetch\n    /// @dev You most likely want to use #observe() instead of this method to get an observation as of some amount of time\n    /// ago, rather than at a specific index in the array.\n    /// @return blockTimestamp The timestamp of the observation,\n    /// @return tickCumulative the tick multiplied by seconds elapsed for the life of the pool as of the observation timestamp,\n    /// @return secondsPerLiquidityCumulativeX128 the seconds per in range liquidity for the life of the pool as of the observation timestamp,\n    /// @return initialized whether the observation has been initialized and the values are safe to use\n    function observations(\n        uint256 index\n    )\n        external\n        view\n        returns (\n            uint32 blockTimestamp,\n            int56 tickCumulative,\n            uint160 secondsPerLiquidityCumulativeX128,\n            bool initialized\n        );\n\n    /// @notice get the period seconds in range of a specific position\n    /// @param period the period number\n    /// @param owner owner address\n    /// @param index position index\n    /// @param tickLower lower bound of range\n    /// @param tickUpper upper bound of range\n    /// @return periodSecondsInsideX96 seconds the position was not in range for the period\n    function positionPeriodSecondsInRange(\n        uint256 period,\n        address owner,\n        uint256 index,\n        int24 tickLower,\n        int24 tickUpper\n    ) external view returns (uint256 periodSecondsInsideX96);\n}\n"
        },
        "contracts/CL/core/interfaces/pool/IRamsesV3PoolDerivedState.sol": {
            "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0;\n\n/// @title Pool state that is not stored\n/// @notice Contains view functions to provide information about the pool that is computed rather than stored on the\n/// blockchain. The functions here may have variable gas costs.\ninterface IRamsesV3PoolDerivedState {\n    /// @notice Returns the cumulative tick and liquidity as of each timestamp `secondsAgo` from the current block timestamp\n    /// @dev To get a time weighted average tick or liquidity-in-range, you must call this with two values, one representing\n    /// the beginning of the period and another for the end of the period. E.g., to get the last hour time-weighted average tick,\n    /// you must call it with secondsAgos = [3600, 0].\n    /// @dev The time weighted average tick represents the geometric time weighted average price of the pool, in\n    /// log base sqrt(1.0001) of token1 / token0. The TickMath library can be used to go from a tick value to a ratio.\n    /// @param secondsAgos From how long ago each cumulative tick and liquidity value should be returned\n    /// @return tickCumulatives Cumulative tick values as of each `secondsAgos` from the current block timestamp\n    /// @return secondsPerLiquidityCumulativeX128s Cumulative seconds per liquidity-in-range value as of each `secondsAgos` from the current block\n    /// timestamp\n    function observe(\n        uint32[] calldata secondsAgos\n    ) external view returns (int56[] memory tickCumulatives, uint160[] memory secondsPerLiquidityCumulativeX128s);\n\n    /// @notice Returns a snapshot of the tick cumulative, seconds per liquidity and seconds inside a tick range\n    /// @dev Snapshots must only be compared to other snapshots, taken over a period for which a position existed.\n    /// I.e., snapshots cannot be compared if a position is not held for the entire period between when the first\n    /// snapshot is taken and the second snapshot is taken.\n    /// @param tickLower The lower tick of the range\n    /// @param tickUpper The upper tick of the range\n    /// @return tickCumulativeInside The snapshot of the tick accumulator for the range\n    /// @return secondsPerLiquidityInsideX128 The snapshot of seconds per liquidity for the range\n    /// @return secondsInside The snapshot of seconds per liquidity for the range\n    function snapshotCumulativesInside(\n        int24 tickLower,\n        int24 tickUpper\n    ) external view returns (int56 tickCumulativeInside, uint160 secondsPerLiquidityInsideX128, uint32 secondsInside);\n}\n"
        },
        "contracts/CL/core/interfaces/pool/IRamsesV3PoolActions.sol": {
            "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0;\n\n/// @title Permissionless pool actions\n/// @notice Contains pool methods that can be called by anyone\ninterface IRamsesV3PoolActions {\n    /// @notice Sets the initial price for the pool\n    /// @dev Price is represented as a sqrt(amountToken1/amountToken0) Q64.96 value\n    /// @param sqrtPriceX96 the initial sqrt price of the pool as a Q64.96\n    function initialize(uint160 sqrtPriceX96) external;\n\n    /// @notice Adds liquidity for the given recipient/tickLower/tickUpper position\n    /// @dev The caller of this method receives a callback in the form of IUniswapV3MintCallback#uniswapV3MintCallback\n    /// in which they must pay any token0 or token1 owed for the liquidity. The amount of token0/token1 due depends\n    /// on tickLower, tickUpper, the amount of liquidity, and the current price.\n    /// @param recipient The address for which the liquidity will be created\n    /// @param index The index for which the liquidity will be created\n    /// @param tickLower The lower tick of the position in which to add liquidity\n    /// @param tickUpper The upper tick of the position in which to add liquidity\n    /// @param amount The amount of liquidity to mint\n    /// @param data Any data that should be passed through to the callback\n    /// @return amount0 The amount of token0 that was paid to mint the given amount of liquidity. Matches the value in the callback\n    /// @return amount1 The amount of token1 that was paid to mint the given amount of liquidity. Matches the value in the callback\n    function mint(\n        address recipient,\n        uint256 index,\n        int24 tickLower,\n        int24 tickUpper,\n        uint128 amount,\n        bytes calldata data\n    ) external returns (uint256 amount0, uint256 amount1);\n\n    /// @notice Collects tokens owed to a position\n    /// @dev Does not recompute fees earned, which must be done either via mint or burn of any amount of liquidity.\n    /// Collect must be called by the position owner. To withdraw only token0 or only token1, amount0Requested or\n    /// amount1Requested may be set to zero. To withdraw all tokens owed, caller may pass any value greater than the\n    /// actual tokens owed, e.g. type(uint128).max. Tokens owed may be from accumulated swap fees or burned liquidity.\n    /// @param recipient The address which should receive the fees collected\n    /// @param index The index of the position to be collected\n    /// @param tickLower The lower tick of the position for which to collect fees\n    /// @param tickUpper The upper tick of the position for which to collect fees\n    /// @param amount0Requested How much token0 should be withdrawn from the fees owed\n    /// @param amount1Requested How much token1 should be withdrawn from the fees owed\n    /// @return amount0 The amount of fees collected in token0\n    /// @return amount1 The amount of fees collected in token1\n    function collect(\n        address recipient,\n        uint256 index,\n        int24 tickLower,\n        int24 tickUpper,\n        uint128 amount0Requested,\n        uint128 amount1Requested\n    ) external returns (uint128 amount0, uint128 amount1);\n\n    /// @notice Burn liquidity from the sender and account tokens owed for the liquidity to the position\n    /// @dev Can be used to trigger a recalculation of fees owed to a position by calling with an amount of 0\n    /// @dev Fees must be collected separately via a call to #collect\n    /// @param index The index for which the liquidity will be burned\n    /// @param tickLower The lower tick of the position for which to burn liquidity\n    /// @param tickUpper The upper tick of the position for which to burn liquidity\n    /// @param amount How much liquidity to burn\n    /// @return amount0 The amount of token0 sent to the recipient\n    /// @return amount1 The amount of token1 sent to the recipient\n    function burn(\n        uint256 index,\n        int24 tickLower,\n        int24 tickUpper,\n        uint128 amount\n    ) external returns (uint256 amount0, uint256 amount1);\n\n    /// @notice Swap token0 for token1, or token1 for token0\n    /// @dev The caller of this method receives a callback in the form of IUniswapV3SwapCallback#uniswapV3SwapCallback\n    /// @param recipient The address to receive the output of the swap\n    /// @param zeroForOne The direction of the swap, true for token0 to token1, false for token1 to token0\n    /// @param amountSpecified The amount of the swap, which implicitly configures the swap as exact input (positive), or exact output (negative)\n    /// @param sqrtPriceLimitX96 The Q64.96 sqrt price limit. If zero for one, the price cannot be less than this\n    /// value after the swap. If one for zero, the price cannot be greater than this value after the swap\n    /// @param data Any data to be passed through to the callback\n    /// @return amount0 The delta of the balance of token0 of the pool, exact when negative, minimum when positive\n    /// @return amount1 The delta of the balance of token1 of the pool, exact when negative, minimum when positive\n    function swap(\n        address recipient,\n        bool zeroForOne,\n        int256 amountSpecified,\n        uint160 sqrtPriceLimitX96,\n        bytes calldata data\n    ) external returns (int256 amount0, int256 amount1);\n\n    \n    /// @notice Receive token0 and/or token1 and pay it back, plus a fee, in the callback\n    /// @dev The caller of this method receives a callback in the form of IUniswapV3FlashCallback#uniswapV3FlashCallback\n    /// @dev Can be used to donate underlying tokens pro-rata to currently in-range liquidity providers by calling\n    /// with 0 amount{0,1} and sending the donation amount(s) from the callback\n    /// @param recipient The address which will receive the token0 and token1 amounts\n    /// @param amount0 The amount of token0 to send\n    /// @param amount1 The amount of token1 to send\n    /// @param data Any data to be passed through to the callback\n    function flash(\n        address recipient,\n        uint256 amount0,\n        uint256 amount1,\n        bytes calldata data\n    ) external;\n    \n\n    /// @notice Increase the maximum number of price and liquidity observations that this pool will store\n    /// @dev This method is no-op if the pool already has an observationCardinalityNext greater than or equal to\n    /// the input observationCardinalityNext.\n    /// @param observationCardinalityNext The desired minimum number of observations for the pool to store\n    function increaseObservationCardinalityNext(uint16 observationCardinalityNext) external;\n}\n"
        },
        "contracts/CL/core/interfaces/pool/IRamsesV3PoolOwnerActions.sol": {
            "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0;\n\n/// @title Permissioned pool actions\n/// @notice Contains pool methods that may only be called by the factory owner\ninterface IRamsesV3PoolOwnerActions {\n    /// @notice Set the denominator of the protocol's % share of the fees\n    function setFeeProtocol() external;\n\n    /// @notice Collect the protocol fee accrued to the pool\n    /// @param recipient The address to which collected protocol fees should be sent\n    /// @param amount0Requested The maximum amount of token0 to send, can be 0 to collect fees in only token1\n    /// @param amount1Requested The maximum amount of token1 to send, can be 0 to collect fees in only token0\n    /// @return amount0 The protocol fee collected in token0\n    /// @return amount1 The protocol fee collected in token1\n    function collectProtocol(\n        address recipient,\n        uint128 amount0Requested,\n        uint128 amount1Requested\n    ) external returns (uint128 amount0, uint128 amount1);\n\n    function setFee(uint24 _fee) external;\n}\n"
        },
        "contracts/CL/core/interfaces/pool/IRamsesV3PoolErrors.sol": {
            "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0;\n\n/// @title Errors emitted by a pool\n/// @notice Contains all custom errors that can be emitted by the pool\ninterface IRamsesV3PoolErrors {\n    /*//////////////////////////////////////////////////////////////\n                            POOL ERRORS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Thrown when the pool is locked during a swap or mint/burn operation\n    error LOK(); // Locked\n\n    /// @notice Thrown when tick lower is greater than upper in position management\n    error TLU(); // Tick Lower > Upper\n\n    /// @notice Thrown when tick lower is less than minimum allowed\n    error TLM(); // Tick Lower < Min\n\n    /// @notice Thrown when tick upper is greater than maximum allowed\n    error TUM(); // Tick Upper > Max\n\n    /// @notice Thrown when the pool is already initialized\n    error AI(); // Already Initialized\n\n    /// @notice Thrown when the first margin value is zero\n    error M0(); // Mint token 0 error\n\n    /// @notice Thrown when the second margin value is zero\n    error M1(); // Mint token1 error\n\n    /// @notice Thrown when amount specified is invalid\n    error AS(); // Amount Specified Invalid\n\n    /// @notice Thrown when input amount is insufficient\n    error IIA(); // Insufficient Input Amount\n\n    /// @notice Thrown when pool lacks sufficient liquidity for operation\n    error L(); // Insufficient Liquidity\n\n    /// @notice Thrown when the first fee value is zero\n    error F0(); // Fee0 issue or Fee = 0\n\n    /// @notice Thrown when the second fee value is zero\n    error F1(); // Fee1 issue\n\n    /// @notice Thrown when square price limit is invalid\n    error SPL(); // Square Price Limit Invalid\n}\n"
        },
        "contracts/CL/core/interfaces/pool/IRamsesV3PoolEvents.sol": {
            "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0;\n\n/// @title Events emitted by a pool\n/// @notice Contains all events emitted by the pool\ninterface IRamsesV3PoolEvents {\n    /// @notice Emitted exactly once by a pool when #initialize is first called on the pool\n    /// @dev Mint/Burn/Swap cannot be emitted by the pool before Initialize\n    /// @param sqrtPriceX96 The initial sqrt price of the pool, as a Q64.96\n    /// @param tick The initial tick of the pool, i.e. log base 1.0001 of the starting price of the pool\n    event Initialize(uint160 sqrtPriceX96, int24 tick);\n\n    /// @notice Emitted when liquidity is minted for a given position\n    /// @param sender The address that minted the liquidity\n    /// @param owner The owner of the position and recipient of any minted liquidity\n    /// @param tickLower The lower tick of the position\n    /// @param tickUpper The upper tick of the position\n    /// @param amount The amount of liquidity minted to the position range\n    /// @param amount0 How much token0 was required for the minted liquidity\n    /// @param amount1 How much token1 was required for the minted liquidity\n    event Mint(\n        address sender,\n        address indexed owner,\n        int24 indexed tickLower,\n        int24 indexed tickUpper,\n        uint128 amount,\n        uint256 amount0,\n        uint256 amount1\n    );\n\n    /// @notice Emitted when fees are collected by the owner of a position\n    /// @dev Collect events may be emitted with zero amount0 and amount1 when the caller chooses not to collect fees\n    /// @param owner The owner of the position for which fees are collected\n    /// @param tickLower The lower tick of the position\n    /// @param tickUpper The upper tick of the position\n    /// @param amount0 The amount of token0 fees collected\n    /// @param amount1 The amount of token1 fees collected\n    event Collect(\n        address indexed owner,\n        address recipient,\n        int24 indexed tickLower,\n        int24 indexed tickUpper,\n        uint128 amount0,\n        uint128 amount1\n    );\n\n    /// @notice Emitted when a position's liquidity is removed\n    /// @dev Does not withdraw any fees earned by the liquidity position, which must be withdrawn via #collect\n    /// @param owner The owner of the position for which liquidity is removed\n    /// @param tickLower The lower tick of the position\n    /// @param tickUpper The upper tick of the position\n    /// @param amount The amount of liquidity to remove\n    /// @param amount0 The amount of token0 withdrawn\n    /// @param amount1 The amount of token1 withdrawn\n    event Burn(\n        address indexed owner,\n        int24 indexed tickLower,\n        int24 indexed tickUpper,\n        uint128 amount,\n        uint256 amount0,\n        uint256 amount1\n    );\n\n    /// @notice Emitted by the pool for any swaps between token0 and token1\n    /// @param sender The address that initiated the swap call, and that received the callback\n    /// @param recipient The address that received the output of the swap\n    /// @param amount0 The delta of the token0 balance of the pool\n    /// @param amount1 The delta of the token1 balance of the pool\n    /// @param sqrtPriceX96 The sqrt(price) of the pool after the swap, as a Q64.96\n    /// @param liquidity The liquidity of the pool after the swap\n    /// @param tick The log base 1.0001 of price of the pool after the swap\n    event Swap(\n        address indexed sender,\n        address indexed recipient,\n        int256 amount0,\n        int256 amount1,\n        uint160 sqrtPriceX96,\n        uint128 liquidity,\n        int24 tick\n    );\n\n    /// @notice Emitted by the pool for any flashes of token0/token1\n    /// @param sender The address that initiated the swap call, and that received the callback\n    /// @param recipient The address that received the tokens from flash\n    /// @param amount0 The amount of token0 that was flashed\n    /// @param amount1 The amount of token1 that was flashed\n    /// @param paid0 The amount of token0 paid for the flash, which can exceed the amount0 plus the fee\n    /// @param paid1 The amount of token1 paid for the flash, which can exceed the amount1 plus the fee\n    event Flash(\n        address indexed sender,\n        address indexed recipient,\n        uint256 amount0,\n        uint256 amount1,\n        uint256 paid0,\n        uint256 paid1\n    );\n\n    /// @notice Emitted by the pool for increases to the number of observations that can be stored\n    /// @dev observationCardinalityNext is not the observation cardinality until an observation is written at the index\n    /// just before a mint/swap/burn.\n    /// @param observationCardinalityNextOld The previous value of the next observation cardinality\n    /// @param observationCardinalityNextNew The updated value of the next observation cardinality\n    event IncreaseObservationCardinalityNext(\n        uint16 observationCardinalityNextOld, uint16 observationCardinalityNextNew\n    );\n\n    /// @notice Emitted when the protocol fee is changed by the pool\n    /// @param feeProtocol0Old The previous value of the token0 protocol fee\n    /// @param feeProtocol1Old The previous value of the token1 protocol fee\n    /// @param feeProtocol0New The updated value of the token0 protocol fee\n    /// @param feeProtocol1New The updated value of the token1 protocol fee\n    event SetFeeProtocol(uint8 feeProtocol0Old, uint8 feeProtocol1Old, uint8 feeProtocol0New, uint8 feeProtocol1New);\n\n    /// @notice Emitted when the collected protocol fees are withdrawn by the factory owner\n    /// @param sender The address that collects the protocol fees\n    /// @param recipient The address that receives the collected protocol fees\n    /// @param amount0 The amount of token0 protocol fees that is withdrawn\n    /// @param amount0 The amount of token1 protocol fees that is withdrawn\n    event CollectProtocol(address indexed sender, address indexed recipient, uint128 amount0, uint128 amount1);\n}\n"
        },
        "contracts/CL/core/libraries/BitMath.sol": {
            "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity ^0.8.0;\n\n/// @title BitMath\n/// @dev This library provides functionality for computing bit properties of an unsigned integer\nlibrary BitMath {\n    /// @notice Returns the index of the most significant bit of the number,\n    ///     where the least significant bit is at index 0 and the most significant bit is at index 255\n    /// @dev The function satisfies the property:\n    ///     x >= 2**mostSignificantBit(x) and x < 2**(mostSignificantBit(x)+1)\n    /// @param x the value for which to compute the most significant bit, must be greater than 0\n    /// @return r the index of the most significant bit\n    function mostSignificantBit(uint256 x) internal pure returns (uint8 r) {\n        require(x > 0);\n\n        unchecked {\n            if (x >= 0x100000000000000000000000000000000) {\n                x >>= 128;\n                r += 128;\n            }\n            if (x >= 0x10000000000000000) {\n                x >>= 64;\n                r += 64;\n            }\n            if (x >= 0x100000000) {\n                x >>= 32;\n                r += 32;\n            }\n            if (x >= 0x10000) {\n                x >>= 16;\n                r += 16;\n            }\n            if (x >= 0x100) {\n                x >>= 8;\n                r += 8;\n            }\n            if (x >= 0x10) {\n                x >>= 4;\n                r += 4;\n            }\n            if (x >= 0x4) {\n                x >>= 2;\n                r += 2;\n            }\n            if (x >= 0x2) r += 1;\n        }\n    }\n\n    /// @notice Returns the index of the least significant bit of the number,\n    ///     where the least significant bit is at index 0 and the most significant bit is at index 255\n    /// @dev The function satisfies the property:\n    ///     (x & 2**leastSignificantBit(x)) != 0 and (x & (2**(leastSignificantBit(x)) - 1)) == 0)\n    /// @param x the value for which to compute the least significant bit, must be greater than 0\n    /// @return r the index of the least significant bit\n    function leastSignificantBit(uint256 x) internal pure returns (uint8 r) {\n        require(x > 0);\n\n        unchecked {\n            r = 255;\n            if (x & type(uint128).max > 0) {\n                r -= 128;\n            } else {\n                x >>= 128;\n            }\n            if (x & type(uint64).max > 0) {\n                r -= 64;\n            } else {\n                x >>= 64;\n            }\n            if (x & type(uint32).max > 0) {\n                r -= 32;\n            } else {\n                x >>= 32;\n            }\n            if (x & type(uint16).max > 0) {\n                r -= 16;\n            } else {\n                x >>= 16;\n            }\n            if (x & type(uint8).max > 0) {\n                r -= 8;\n            } else {\n                x >>= 8;\n            }\n            if (x & 0xf > 0) {\n                r -= 4;\n            } else {\n                x >>= 4;\n            }\n            if (x & 0x3 > 0) {\n                r -= 2;\n            } else {\n                x >>= 2;\n            }\n            if (x & 0x1 > 0) r -= 1;\n        }\n    }\n}\n"
        },
        "contracts/CL/core/libraries/FixedPoint32.sol": {
            "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.4.0;\n\n/// @title FixedPoint32\n/// @notice A library for handling binary fixed point numbers, see https://en.wikipedia.org/wiki/Q_(number_format)\nlibrary FixedPoint32 {\n    uint8 internal constant RESOLUTION = 32;\n    uint256 internal constant Q32 = 0x100000000;\n}\n"
        },
        "contracts/CL/core/libraries/FixedPoint96.sol": {
            "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.4.0;\n\n/// @title FixedPoint96\n/// @notice A library for handling binary fixed point numbers, see https://en.wikipedia.org/wiki/Q_(number_format)\n/// @dev Used in SqrtPriceMath.sol\nlibrary FixedPoint96 {\n    uint8 internal constant RESOLUTION = 96;\n    uint256 internal constant Q96 = 0x1000000000000000000000000;\n}\n"
        },
        "contracts/CL/core/libraries/UnsafeMath.sol": {
            "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0;\n\n/// @title Math functions that do not check inputs or outputs\n/// @notice Contains methods that perform common math functions but do not do any overflow or underflow checks\nlibrary UnsafeMath {\n    /// @notice Returns ceil(x / y)\n    /// @dev division by 0 has unspecified behavior, and must be checked externally\n    /// @param x The dividend\n    /// @param y The divisor\n    /// @return z The quotient, ceil(x / y)\n    function divRoundingUp(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        assembly {\n            z := add(div(x, y), gt(mod(x, y), 0))\n        }\n    }\n}\n"
        },
        "dependencies/@openzeppelin-contracts-5.1.0/token/ERC20/IERC20.sol": {
            "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Interface of the ERC-20 standard as defined in the ERC.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the value of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the value of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 value) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\n     * caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 value) external returns (bool);\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the\n     * allowance mechanism. `value` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\n}\n"
        }
    },
    "settings": {
        "remappings": [
            "@layerzerolabs/=node_modules/@layerzerolabs/",
            "@layerzerolabs/lz-evm-protocol-v2/=node_modules/@layerzerolabs/lz-evm-protocol-v2/",
            "@openzeppelin-contracts-upgradeable/=dependencies/@openzeppelin-contracts-upgradeable-5.1.0/",
            "@openzeppelin-contracts/contracts/=dependencies/@openzeppelin-contracts-5.1.0/",
            "@openzeppelin/contracts-upgradeable/=dependencies/@openzeppelin-contracts-upgradeable-5.1.0/",
            "@openzeppelin/contracts/=dependencies/@openzeppelin-contracts-5.1.0/",
            "erc4626-tests/=dependencies/erc4626-property-tests-1.0/",
            "forge-std/=dependencies/forge-std-1.9.4/src/",
            "permit2/=lib/permit2/",
            "@openzeppelin-3.4.2/=node_modules/@openzeppelin-3.4.2/",
            "@openzeppelin-contracts-5.1.0/=dependencies/@openzeppelin-contracts-5.1.0/",
            "@openzeppelin-contracts-upgradeable-5.1.0/=dependencies/@openzeppelin-contracts-upgradeable-5.1.0/",
            "@uniswap/=node_modules/@uniswap/",
            "base64-sol/=node_modules/base64-sol/",
            "erc4626-property-tests-1.0/=dependencies/erc4626-property-tests-1.0/",
            "eth-gas-reporter/=node_modules/eth-gas-reporter/",
            "forge-std-1.9.4/=dependencies/forge-std-1.9.4/src/",
            "hardhat/=node_modules/hardhat/",
            "solidity-bytes-utils/=node_modules/solidity-bytes-utils/",
            "solmate/=node_modules/solmate/"
        ],
        "optimizer": {
            "enabled": true,
            "runs": 200
        },
        "metadata": {
            "useLiteralContent": false,
            "bytecodeHash": "none",
            "appendCBOR": true
        },
        "outputSelection": {
            "*": {
                "*": [
                    "abi",
                    "evm.bytecode.object",
                    "evm.bytecode.sourceMap",
                    "evm.bytecode.linkReferences",
                    "evm.deployedBytecode.object",
                    "evm.deployedBytecode.sourceMap",
                    "evm.deployedBytecode.linkReferences",
                    "evm.deployedBytecode.immutableReferences",
                    "evm.methodIdentifiers",
                    "metadata"
                ]
            }
        },
        "evmVersion": "cancun",
        "viaIR": true,
        "libraries": {}
    }
}